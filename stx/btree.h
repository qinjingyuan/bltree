/*******************************************************************************
 * include/stx/btree.h
 *
 * STX B+ Tree Template Classes v0.9
 * Copyright (C) 2008-2013 Timo Bingmann <tb@panthema.net>
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

#define SHIFT_BITS 50

#ifndef STX_STX_BTREE_H_HEADER
#define STX_STX_BTREE_H_HEADER

/**
 * \file include/stx/btree.h
 * Contains the main B+ tree implementation template class btree.
 */

// *** Required Headers from the STL
#include <bits/stdc++.h>
#include <algorithm>
#include <cstdlib>
#include <functional>
#include <istream>
#include <ostream>
#include <memory>
#include <cstddef>
#include <cassert>
#include <chrono>
#include <iostream>
#include <cmath>
#include <string>
// *** Debugging Macros

// #include <Eigen/Dense>
#include <vector>
#include <numeric>
#ifdef BTREE_DEBUG

#include <iostream>

/// Print out debug information to std::cout if BTREE_DEBUG is defined.
#define BTREE_PRINT(x)          do { if (debug) (std::cout << x << std::endl); } while (0)

/// Assertion only if BTREE_DEBUG is defined. This is not used in verify().
#define BTREE_ASSERT(x)         do { assert(x); } while (0)

#else

/// Print out debug information to std::cout if BTREE_DEBUG is defined.
#define BTREE_PRINT(x)          do { } while (0)

/// Assertion only if BTREE_DEBUG is defined. This is not used in verify().
#define BTREE_ASSERT(x)         do { } while (0)

#endif

/// The maximum of a and b. Used in some compile-time formulas.
#define BTREE_MAX(a, b)          ((a) < (b) ? (b) : (a))

#ifndef BTREE_FRIENDS
/// The macro BTREE_FRIENDS can be used by outside class to access the B+
/// tree internals. This was added for wxBTreeDemo to be able to draw the
/// tree.
#define BTREE_FRIENDS           friend class btree_friend;
#endif

/// STX - Some Template Extensions namespace
namespace stx {

size_t level_delay[5] = {0};
size_t level_delay_count[5] = {0};
size_t gaps[5] = {0};
size_t gaps_count[5] = {0};
size_t data_distribution_count[10] = {0};
size_t data_distribution_count_inner[10] = {0};
size_t exec_times[5];
size_t exec_counts[5];
size_t node_type_counts[7] = {0};


size_t table_x2[] = {0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484,529,576,625,676,729,784,841,900,961,1024,1089,1156,1225,1296,1369,1444,1521,1600,1681,1764,1849,1936,2025,2116,2209,2304,2401,2500,2601,2704,2809,2916,3025,3136,3249,3364,3481,3600,3721,3844,3969,4096,4225,4356,4489,4624,4761,4900,5041,5184,5329,5476,5625,5776,5929,6084,6241,6400,6561,6724,6889,7056,7225,7396,7569,7744,7921,8100,8281,8464,8649,8836,9025,9216,9409,9604,9801,10000,10201,10404,10609,10816,11025,11236,11449,11664,11881,12100,12321,12544,12769,12996,13225,13456,13689,13924,14161,14400,14641,14884,15129,15376,15625,15876,16129,16384,16641,16900,17161,17424,17689,17956,18225,18496,18769,19044,19321,19600,19881,20164,20449,20736,21025,21316,21609,21904,22201,22500,22801,23104,23409,23716,24025,24336,24649,24964,25281,25600,25921,26244,26569,26896,27225,27556,27889,28224,28561,28900,29241,29584,29929,30276,30625,30976,31329,31684,32041,32400,32761,33124,33489,33856,34225,34596,34969,35344,35721,36100,36481,36864,37249,37636,38025,38416,38809,39204,39601,40000,40401,40804,41209,41616,42025,42436,42849,43264,43681,44100,44521,44944,45369,45796,46225,46656,47089,47524,47961,48400,48841,49284,49729,50176,50625,51076,51529,51984,52441,52900,53361,53824,54289,54756,55225,55696,56169,56644,57121,57600,58081,58564,59049,59536,60025,60516,61009,61504,62001,62500,63001,63504,64009,64516,65025,65536,66049,66564,67081,67600,68121,68644,69169,69696,70225,70756,71289,71824,72361,72900,73441,73984,74529,75076,75625,76176,76729,77284,77841,78400,78961,79524,80089,80656,81225,81796,82369,82944,83521,84100,84681,85264,85849,86436,87025,87616,88209,88804,89401,90000,90601,91204,91809,92416,93025,93636,94249,94864,95481,96100,96721,97344,97969,98596,99225,99856,100489,101124,101761,102400,103041,103684,104329,104976,105625,106276,106929,107584,108241,108900,109561,110224,110889,111556,112225,112896,113569,114244,114921,115600,116281,116964,117649,118336,119025,119716,120409,121104,121801,122500,123201,123904,124609,125316,126025,126736,127449,128164,128881,129600,130321,131044,131769,132496,133225,133956,134689,135424,136161,136900,137641,138384,139129,139876,140625,141376,142129,142884,143641,144400,145161,145924,146689,147456,148225,148996,149769,150544,151321,152100,152881,153664,154449,155236,156025,156816,157609,158404,159201,160000,160801,161604,162409,163216,164025,164836,165649,166464,167281,168100,168921,169744,170569,171396,172225,173056,173889,174724,175561,176400,177241,178084,178929,179776,180625,181476,182329,183184,184041,184900,185761,186624,187489,188356,189225,190096,190969,191844,192721,193600,194481,195364,196249,197136,198025,198916,199809,200704,201601,202500,203401,204304,205209,206116,207025,207936,208849,209764,210681,211600,212521,213444,214369,215296,216225,217156,218089,219024,219961,220900,221841,222784,223729,224676,225625,226576,227529,228484,229441,230400,231361,232324,233289,234256,235225,236196,237169,238144,239121,240100,241081,242064,243049,244036,245025,246016,247009,248004,249001,250000,251001,252004,253009,254016,255025,256036,257049,258064,259081,260100,261121};
size_t table_x3[] = {0,1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832,6859,8000,9261,10648,12167,13824,15625,17576,19683,21952,24389,27000,29791,32768,35937,39304,42875,46656,50653,54872,59319,64000,68921,74088,79507,85184,91125,97336,103823,110592,117649,125000,132651,140608,148877,157464,166375,175616,185193,195112,205379,216000,226981,238328,250047,262144,274625,287496,300763,314432,328509,343000,357911,373248,389017,405224,421875,438976,456533,474552,493039,512000,531441,551368,571787,592704,614125,636056,658503,681472,704969,729000,753571,778688,804357,830584,857375,884736,912673,941192,970299,1000000,1030301,1061208,1092727,1124864,1157625,1191016,1225043,1259712,1295029,1331000,1367631,1404928,1442897,1481544,1520875,1560896,1601613,1643032,1685159,1728000,1771561,1815848,1860867,1906624,1953125,2000376,2048383,2097152,2146689,2197000,2248091,2299968,2352637,2406104,2460375,2515456,2571353,2628072,2685619,2744000,2803221,2863288,2924207,2985984,3048625,3112136,3176523,3241792,3307949,3375000,3442951,3511808,3581577,3652264,3723875,3796416,3869893,3944312,4019679,4096000,4173281,4251528,4330747,4410944,4492125,4574296,4657463,4741632,4826809,4913000,5000211,5088448,5177717,5268024,5359375,5451776,5545233,5639752,5735339,5832000,5929741,6028568,6128487,6229504,6331625,6434856,6539203,6644672,6751269,6859000,6967871,7077888,7189057,7301384,7414875,7529536,7645373,7762392,7880599,8000000,8120601,8242408,8365427,8489664,8615125,8741816,8869743,8998912,9129329,9261000,9393931,9528128,9663597,9800344,9938375,10077696,10218313,10360232,10503459,10648000,10793861,10941048,11089567,11239424,11390625,11543176,11697083,11852352,12008989,12167000,12326391,12487168,12649337,12812904,12977875,13144256,13312053,13481272,13651919,13824000,13997521,14172488,14348907,14526784,14706125,14886936,15069223,15252992,15438249,15625000,15813251,16003008,16194277,16387064,16581375,16777216,16974593,17173512,17373979,17576000,17779581,17984728,18191447,18399744,18609625,18821096,19034163,19248832,19465109,19683000,19902511,20123648,20346417,20570824,20796875,21024576,21253933,21484952,21717639,21952000,22188041,22425768,22665187,22906304,23149125,23393656,23639903,23887872,24137569,24389000,24642171,24897088,25153757,25412184,25672375,25934336,26198073,26463592,26730899,27000000,27270901,27543608,27818127,28094464,28372625,28652616,28934443,29218112,29503629,29791000,30080231,30371328,30664297,30959144,31255875,31554496,31855013,32157432,32461759,32768000,33076161,33386248,33698267,34012224,34328125,34645976,34965783,35287552,35611289,35937000,36264691,36594368,36926037,37259704,37595375,37933056,38272753,38614472,38958219,39304000,39651821,40001688,40353607,40707584,41063625,41421736,41781923,42144192,42508549,42875000,43243551,43614208,43986977,44361864,44738875,45118016,45499293,45882712,46268279,46656000,47045881,47437928,47832147,48228544,48627125,49027896,49430863,49836032,50243409,50653000,51064811,51478848,51895117,52313624,52734375,53157376,53582633,54010152,54439939,54872000,55306341,55742968,56181887,56623104,57066625,57512456,57960603,58411072,58863869,59319000,59776471,60236288,60698457,61162984,61629875,62099136,62570773,63044792,63521199,64000000,64481201,64964808,65450827,65939264,66430125,66923416,67419143,67917312,68417929,68921000,69426531,69934528,70444997,70957944,71473375,71991296,72511713,73034632,73560059,74088000,74618461,75151448,75686967,76225024,76765625,77308776,77854483,78402752,78953589,79507000,80062991,80621568,81182737,81746504,82312875,82881856,83453453,84027672,84604519,85184000,85766121,86350888,86938307,87528384,88121125,88716536,89314623,89915392,90518849,91125000,91733851,92345408,92959677,93576664,94196375,94818816,95443993,96071912,96702579,97336000,97972181,98611128,99252847,99897344,100544625,101194696,101847563,102503232,103161709,103823000,104487111,105154048,105823817,106496424,107171875,107850176,108531333,109215352,109902239,110592000,111284641,111980168,112678587,113379904,114084125,114791256,115501303,116214272,116930169,117649000,118370771,119095488,119823157,120553784,121287375,122023936,122763473,123505992,124251499,125000000,125751501,126506008,127263527,128024064,128787625,129554216,130323843,131096512,131872229,132651000,133432831};
size_t table_x4[] = {0,1,16,81,256,625,1296,2401,4096,6561,10000,14641,20736,28561,38416,50625,65536,83521,104976,130321,160000,194481,234256,279841,331776,390625,456976,531441,614656,707281,810000,923521,1048576,1185921,1336336,1500625,1679616,1874161,2085136,2313441,2560000,2825761,3111696,3418801,3748096,4100625,4477456,4879681,5308416,5764801,6250000,6765201,7311616,7890481,8503056,9150625,9834496,10556001,11316496,12117361,12960000,13845841,14776336,15752961,16777216,17850625,18974736,20151121,21381376,22667121,24010000,25411681,26873856,28398241,29986576,31640625,33362176,35153041,37015056,38950081,40960000,43046721,45212176,47458321,49787136,52200625,54700816,57289761,59969536,62742241,65610000,68574961,71639296,74805201,78074896,81450625,84934656,88529281,92236816,96059601,100000000,104060401,108243216,112550881,116985856,121550625,126247696,131079601,136048896,141158161,146410000,151807041,157351936,163047361,168896016,174900625,181063936,187388721,193877776,200533921,207360000,214358881,221533456,228886641,236421376,244140625,252047376,260144641,268435456,276922881,285610000,294499921,303595776,312900721,322417936,332150625,342102016,352275361,362673936,373301041,384160000,395254161,406586896,418161601,429981696,442050625,454371856,466948881,479785216,492884401,506250000,519885601,533794816,547981281,562448656,577200625,592240896,607573201,623201296,639128961,655360000,671898241,688747536,705911761,723394816,741200625,759333136,777796321,796594176,815730721,835210000,855036081,875213056,895745041,916636176,937890625,959512576,981506241,1003875856,1026625681,1049760000,1073283121,1097199376,1121513121,1146228736,1171350625,1196883216,1222830961,1249198336,1275989841,1303210000,1330863361,1358954496,1387488001,1416468496,1445900625,1475789056,1506138481,1536953616,1568239201,1600000000,1632240801,1664966416,1698181681,1731891456,1766100625,1800814096,1836036801,1871773696,1908029761,1944810000,1982119441,2019963136,2058346161,2097273616,2136750625,2176782336,2217373921,2258530576,2300257521,2342560000,2385443281,2428912656,2472973441,2517630976,2562890625,2608757776,2655237841,2702336256,2750058481,2798410000,2847396321,2897022976,2947295521,2998219536,3049800625,3102044416,3154956561,3208542736,3262808641,3317760000,3373402561,3429742096,3486784401,3544535296,3603000625,3662186256,3722098081,3782742016,3844124001,3906250000,3969126001,4032758016,4097152081,4162314256,4228250625,4294967296,4362470401,4430766096,4499860561,4569760000,4640470641,4711998736,4784350561,4857532416,4931550625,5006411536,5082121521,5158686976,5236114321,5314410000,5393580481,5473632256,5554571841,5636405776,5719140625,5802782976,5887339441,5972816656,6059221281,6146560000,6234839521,6324066576,6414247921,6505390336,6597500625,6690585616,6784652161,6879707136,6975757441,7072810000,7170871761,7269949696,7370050801,7471182096,7573350625,7676563456,7780827681,7886150416,7992538801,8100000000,8208541201,8318169616,8428892481,8540717056,8653650625,8767700496,8882874001,8999178496,9116621361,9235210000,9354951841,9475854336,9597924961,9721171216,9845600625,9971220736,10098039121,10226063376,10355301121,10485760000,10617447681,10750371856,10884540241,11019960576,11156640625,11294588176,11433811041,11574317056,11716114081,11859210000,12003612721,12149330176,12296370321,12444741136,12594450625,12745506816,12897917761,13051691536,13206836241,13363360000,13521270961,13680577296,13841287201,14003408896,14166950625,14331920656,14498327281,14666178816,14835483601,15006250000,15178486401,15352201216,15527402881,15704099856,15882300625,16062013696,16243247601,16426010896,16610312161,16796160000,16983563041,17172529936,17363069361,17555190016,17748900625,17944209936,18141126721,18339659776,18539817921,18741610000,18945044881,19150131456,19356878641,19565295376,19775390625,19987173376,20200652641,20415837456,20632736881,20851360000,21071715921,21293813776,21517662721,21743271936,21970650625,22199808016,22430753361,22663495936,22898045041,23134410000,23372600161,23612624896,23854493601,24098215696,24343800625,24591257856,24840596881,25091827216,25344958401,25600000000,25856961601,26115852816,26376683281,26639462656,26904200625,27170906896,27439591201,27710263296,27982932961,28257610000,28534304241,28813025536,29093783761,29376588816,29661450625,29948379136,30237384321,30528476176,30821664721,31116960000,31414372081,31713911056,32015587041,32319410176,32625390625,32933538576,33243864241,33556377856,33871089681,34188010000,34507149121,34828517376,35152125121,35477982736,35806100625,36136489216,36469158961,36804120336,37141383841,37480960000,37822859361,38167092496,38513670001,38862602496,39213900625,39567575056,39923636481,40282095616,40642963201,41006250000,41371966801,41740124416,42110733681,42483805456,42859350625,43237380096,43617904801,44000935696,44386483761,44774560000,45165175441,45558341136,45954068161,46352367616,46753250625,47156728336,47562811921,47971512576,48382841521,48796810000,49213429281,49632710656,50054665441,50479304976,50906640625,51336683776,51769445841,52204938256,52643172481,53084160000,53527912321,53974440976,54423757521,54875873536,55330800625,55788550416,56249134561,56712564736,57178852641,57648010000,58120048561,58594980096,59072816401,59553569296,60037250625,60523872256,61013446081,61505984016,62001498001,62500000000,63001502001,63506016016,64013554081,64524128256,65037750625,65554433296,66074188401,66597028096,67122964561,67652010000,68184176641};
size_t table_x6[] = {0,1,64,729,4096,15625,46656,117649,262144,531441,1000000,1771561,2985984,4826809,7529536,11390625,16777216,24137569,34012224,47045881,64000000,85766121,113379904,148035889,191102976,244140625,308915776,387420489,481890304,594823321,729000000,887503681,1073741824,1291467969,1544804416,1838265625,2176782336,2565726409,3010936384,3518743761,4096000000,4750104241,5489031744,6321363049,7256313856,8303765625,9474296896,10779215329,12230590464,13841287201,15625000000,17596287801,19770609664,22164361129,24794911296,27680640625,30840979456,34296447249,38068692544,42180533641,46656000000,51520374361,56800235584,62523502209,68719476736,75418890625,82653950016,90458382169,98867482624,107918163081,117649000000,128100283921,139314069504,151334226289,164206490176,177978515625,192699928576,208422380089,225199600704,243087455521,262144000000,282429536481,304006671424,326940373369,351298031616,377149515625,404567235136,433626201009,464404086784,496981290961,531441000000,567869252041,606355001344,646990183449,689869781056,735091890625,782757789696,832972004929,885842380864,941480149401,1000000000000,1061520150601,1126162419264,1194052296529,1265319018496,1340095640625,1418519112256,1500730351849,1586874322944,1677100110841,1771561000000,1870414552161,1973822685184,2081951752609,2194972623936,2313060765625,2436396322816,2565164201769,2699554153024,2839760855281,2985984000000,3138428376721,3297303959104,3462825991689,3635215077376,3814697265625,4001504141376,4195872914689,4398046511104,4608273662721,4826809000000,5053913144281,5289852801024,5534900853769,5789336458816,6053445140625,6327518887936,6611856250609,6906762437184,7212549413161,7529536000000,7858047974841,8198418170944,8550986578849,8916100448256,9294114390625,9685390482496,10090298369529,10509215371264,10942526586601,11390625000000,11853911588401,12332795428864,12827693806929,13339032325696,13867245015625,14412774445056,14976071831449,15557597153344,16157819263041,16777216000000,17416274304961,18075490334784,18755369578009,19456426971136,20179187015625,20924183895616,21691961596369,22483074023424,23298085122481,24137569000000,25002110044521,25892303048704,26808753332089,27752076864576,28722900390625,29721861554176,30749609024289,31806802621504,32894113444921,34012224000000,35161828327081,36343632130624,37558352909169,38806720086016,40089475140625,41407371740736,42761175875209,44151665987584,45579633110361,47045881000000,48551226272641,50096498540544,51682540549249,53310208315456,54980371265625,56693912375296,58451728309129,60254729561664,62103840598801,64000000000000,65944160601201,67937289638464,69980368892329,72074394832896,74220378765625,76419346977856,78672340886049,80980417183744,83344647990241,85766121000000,88245939632761,90785223184384,93385106978409,96046742518336,98771297640625,101559956668416,104413920565969,107334407093824,110322650964681,113379904000000,116507435287321,119706531338304,122978496247489,126324651851776,129746337890625,133244912166976,136821750708889,140478247931904,144215816802121,148035889000000,151939915084881,155929364660224,160005726539569,164170508913216,168425239515625,172771465793536,177210755074809,181744694737984,186374892382561,191102976000000,195930594145441,200859416110144,205891132094649,211027453382656,216270112515625,221620863468096,227081481823729,232653764952064,238339532186001,244140625000000,250058907189001,256096265048064,262254607552729,268535866540096,274941996890625,281474976710656,288136807515649,294929514414144,301855146292441,308915776000000,316113500535561,323450441233984,330928743953809,338550579265536,346318142640625,354233654641216,362299361110569,370517533364224,378890468381881,387420489000000,396109944105121,404961208827904,413976684737889,423158800038976,432510009765625,442032795979776,451729667968489,461603162442304,471655843734321,481890304000000,492309163417681,502915070389824,513710701744969,524698762940416,535881988265625,547263141046336,558845013849409,570630428688384,582622237229761,594823321000000,607236591593241,619864990879744,632711491215049,645779095649856,659070838140625,672589783760896,686339028913329,700321701542464,714540961348201,729000000000000,743702041351801,758650341657664,773848189788129,789298907447296,805005849390625,820972403643456,837201991720249,853698068844544,870464124169641,887503681000000,904820297013361,922417564483584,940299110504209,958468597212736,976929722015625,995686217814016,1014741853230169,1034100432834624,1053765797374081,1073741824000000,1094032426497921,1114641555517504,1135573198803289,1156831381426176,1178420166015625,1200343652992576,1222605980803089,1245211326152704,1268163904241521,1291467969000000,1315127813325481,1339147769319424,1363532208525369,1388285542167616,1413412221390625,1438916737499136,1464803622199009,1491077447838784,1517742827651961,1544804416000000,1572266908616041,1600135042849344,1628413597910449,1657107395117056,1686221298140625,1715760213253696,1745729089577929,1776132919332864,1806976738085401,1838265625000000,1870004703089601,1902199139467264,1934854145598529,1967974977554496,2001566936265625,2035635367776256,2070185663499849,2105223260474944,2140753641621841,2176782336000000,2213314919066161,2250357012933184,2287914286629609,2325992456359936,2364597285765625,2403734586186816,2443410216924769,2483630085505024,2524400147941281,2565726409000000,2607614922465721,2650071791407104,2693103168443689,2736715256013376,2780914306640625,2825706623205376,2871098559212689,2917096519063104,2963706958323721,3010936384000000,3058791354808281,3107278481449024,3156404426880769,3206175906594816,3256599688890625,3307682595151936,3359431500123609,3411853332189184,3464955073649161,3518743761000000,3573226485213841,3628410392018944,3684302682180849,3740910611784256,3798241492515625,3856302691946496,3915101633817529,3974645798323264,4034942722397601,4096000000000000,4157825282402401,4220426278476864,4283810754983929,4347986536861696,4412961507515625,4478743609109056,4545340842854449,4612761269305344,4681013008649041,4750104241000000,4820043206693961,4890838206582784,4962497602330009,5035029816707136,5108443333890625,5182746699759616,5257948522194369,5334057471375424,5411082280083481,5489031744000000,5567914722008521,5647740136496704,5728516973659089,5810254283800576,5892961181640625,5976646846618176,6061320523197289,6146991521173504,6233669215980921,6321363049000000,6410082527866081,6499837226778624,6590636786811169,6682490916222016,6775409390765625,6869402054004736,6964478817623209,7060649661739584,7157924635221361,7256313856000000,7355827511386641,7456475858388544,7558269224026249,7661218005651456,7765332671265625,7870623759839296,7977101881632129,8084777718513664,8193662024284801,8303765625000000,8415099419290201,8527674378686464,8641501547944329,8756592045368896,8872957063140625,8990607867641856,9109555799784049,9229812275335744,9351388785251241,9474296896000000,9598548249896761,9724154565432384,9851127637605409,9979479338254336,10109221616390625,10240366498532416,10372926089038969,10506912570445824,10642338203800681,10779215329000000,10917556365126321,11057373810786304,11198680244449489,11341488324787776,11485810791015625,11631660463230976,11779050242756889,11927993112483904,12078502137213121,12230590464000000,12384271322498881,12539558025308224,12696463968316569,12855002631049216,13015187577015625,13177032454057536,13340550994697809,13505757016489984,13672664422368561,13841287201000000,14011639427134441,14183735261958144,14357588953446649,14533214836718656,14710627334390625,14889840956932096,15070870303021729,15253730059904064,15438435003747001,15625000000000000,15813440003753001,16003770060096064,16196005304479729,16390160963076096,16586252353140625,16784294883374656,16984304054288649,17186295458566144,17390284781428441,17596287801000000,17804320388674561};

enum modelType  {LINE=0,BINOMIAL,GENERAL,X4,SINX001,X2,LINE_X,X3,X2R,X2D,LINE_EXP,GAPX6,GAPX2,GAPX3,LINE_INT,S1,S2,TU,AO,SX,LN};



struct DataPoint
{
    double m_x {};
    double m_y {};
};

const std::pair<double, double>& LinearRegressionModelTrain(const std::vector<DataPoint>& point_data)
{
    static std::pair<double, double> model_parameter {};

    // Calculate the x mean.
    double x_mean = std::accumulate( point_data.begin(), point_data.end(), 0.0,
        [](double a, DataPoint tmp) -> double { 
            return a + tmp.m_x; 
            } ) / point_data.size();

    // Calculate the y mean.
    double y_mean = std::accumulate( point_data.begin(), point_data.end(), 0.0,
        [](double a, DataPoint tmp) -> double { 
            return a + tmp.m_y; 
            } ) / point_data.size();

    // Calculate the beta1 value.
    double beta1_numerator {};
    double beta1_denominator {};

    for (std::size_t i = 0; i < point_data.size(); ++i)
    {
        beta1_numerator += point_data[i].m_y * (point_data[i].m_x - x_mean);
        beta1_denominator += std::pow(point_data[i].m_x, 2) - ( point_data[i].m_x * x_mean );
    }

    // beta1
    model_parameter.second = beta1_numerator / beta1_denominator;
    // beta0
    model_parameter.first = y_mean - x_mean * model_parameter.second;

    return model_parameter;
}


/** Generates default traits for a B+ tree used as a set. It estimates leaf and
 * inner node sizes by assuming a cache line size of 256 bytes. */
template <typename _Key>
class btree_default_set_traits
{
public:
    /// If true, the tree will self verify it's invariants after each insert()
    /// or erase(). The header must have been compiled with BTREE_DEBUG defined.
    static const bool selfverify = false;

    /// If true, the tree will print out debug information and a tree dump
    /// during insert() or erase() operation. The header must have been
    /// compiled with BTREE_DEBUG defined and key_type must be std::ostream
    /// printable.
    static const bool debug = false;

    /// Number of slots in each leaf of the tree. Estimated so that each node
    /// has a size of about 256 bytes.
    static const int leafslots = BTREE_MAX(8, 256 / (sizeof(_Key)));

    /// Number of slots in each inner node of the tree. Estimated so that each node
    /// has a size of about 256 bytes.
    static const int innerslots = BTREE_MAX(8, 256 / (sizeof(_Key) + sizeof(void*)));

    /// As of stx-btree-0.9, the code does linear search in find_lower() and
    /// find_upper() instead of binary_search, unless the node size is larger
    /// than this threshold. See notes at
    /// http://panthema.net/2013/0504-STX-B+Tree-Binary-vs-Linear-Search
    static const size_t binsearch_threshold = 256;
};

/** Generates default traits for a B+ tree used as a map. It estimates leaf and
 * inner node sizes by assuming a cache line size of 256 bytes. */
template <typename _Key, typename _Data>
class btree_default_map_traits
{
public:
    /// If true, the tree will self verify it's invariants after each insert()
    /// or erase(). The header must have been compiled with BTREE_DEBUG defined.
    static const bool selfverify = false;

    /// If true, the tree will print out debug information and a tree dump
    /// during insert() or erase() operation. The header must have been
    /// compiled with BTREE_DEBUG defined and key_type must be std::ostream
    /// printable.
    static const bool debug = false;

    /// Number of slots in each leaf of the tree. Estimated so that each node
    /// has a size of about 256 bytes.
    static const int leafslots = BTREE_MAX(8, 256 / (sizeof(_Key) + sizeof(_Data)));

    /// Number of slots in each inner node of the tree. Estimated so that each node
    /// has a size of about 256 bytes.
    static const int innerslots = BTREE_MAX(8, 256 / (sizeof(_Key) + sizeof(void*)));

    /// As of stx-btree-0.9, the code does linear search in find_lower() and
    /// find_upper() instead of binary_search, unless the node size is larger
    /// than this threshold. See notes at
    /// http://panthema.net/2013/0504-STX-B+Tree-Binary-vs-Linear-Search
    static const size_t binsearch_threshold = 32;
};

/** @brief Basic class implementing a base B+ tree data structure in memory.
 *
 * The base implementation of a memory B+ tree. It is based on the
 * implementation in Cormen's Introduction into Algorithms, Jan Jannink's paper
 * and other algorithm resources. Almost all STL-required function calls are
 * implemented. The asymptotic time requirements of the STL are not always
 * fulfilled in theory, however in practice this B+ tree performs better than a
 * red-black tree by using more memory. The insertion function splits the nodes
 * on the recursion unroll. Erase is largely based on Jannink's ideas.
 *
 * This class is specialized into btree_set, btree_multiset, btree_map and
 * btree_multimap using default template parameters and facade functions.
 */
template <typename _Key, typename _Data,
          typename _Value = std::pair<_Key, _Data>,
          typename _Compare = std::less<_Key>,
          typename _Traits = btree_default_map_traits<_Key, _Data>,
          bool _Duplicates = false,
          typename _Alloc = std::allocator<_Value>,
          bool _UsedAsSet = false>
class btree
{
public:

    int btree_level=0;
    // *** Template Parameter Types

    /// First template parameter: The key type of the B+ tree. This is stored
    /// in inner nodes and leaves
    typedef _Key key_type;

    /// Second template parameter: The data type associated with each
    /// key. Stored in the B+ tree's leaves
    typedef _Data data_type;

    /// Third template parameter: Composition pair of key and data types, this
    /// is required by the STL standard. The B+ tree does not store key and
    /// data together. If value_type == key_type then the B+ tree implements a
    /// set.
    typedef _Value value_type;

    /// Fourth template parameter: Key comparison function object
    typedef _Compare key_compare;

    /// Fifth template parameter: Traits object used to define more parameters
    /// of the B+ tree
    typedef _Traits traits;

    /// Sixth template parameter: Allow duplicate keys in the B+ tree. Used to
    /// implement multiset and multimap.
    static const bool allow_duplicates = _Duplicates;

    /// Seventh template parameter: STL allocator for tree nodes
    typedef _Alloc allocator_type;

    /// Eighth template parameter: boolean indicator whether the btree is used
    /// as a set. In this case all operations on the data arrays are
    /// omitted. This flag is kind of hacky, but required because
    /// sizeof(empty_struct) = 1 due to the C standard. Without the flag, lots
    /// of superfluous copying would occur.
    static const bool used_as_set = _UsedAsSet;

    // The macro BTREE_FRIENDS can be used by outside class to access the B+
    // tree internals. This was added for wxBTreeDemo to be able to draw the
    // tree.
    BTREE_FRIENDS

public:
    // *** Constructed Types

    /// Typedef of our own type
    typedef btree<key_type, data_type, value_type, key_compare,
                  traits, allow_duplicates, allocator_type, used_as_set> self_type;

    /// Size type used to count keys
    typedef size_t size_type;

    /// The pair of key_type and data_type, this may be different from
    /// value_type.
    typedef std::pair<key_type, data_type> pair_type;

public:
    // *** Static Constant Options and Values of the B+ Tree

    /// Base B+ tree parameter: The number of key/data slots in each leaf
    static const unsigned short leafslotmax = traits::leafslots;

    /// Base B+ tree parameter: The number of key slots in each inner node,
    /// this can differ from slots in each leaf.
    static const unsigned short innerslotmax = traits::innerslots;

    /// Computed B+ tree parameter: The minimum number of key/data slots used
    /// in a leaf. If fewer slots are used, the leaf will be merged or slots
    /// shifted from it's siblings.
    static const unsigned short minleafslots = (leafslotmax / 2);

    /// Computed B+ tree parameter: The minimum number of key slots used
    /// in an inner node. If fewer slots are used, the inner node will be
    /// merged or slots shifted from it's siblings.
    static const unsigned short mininnerslots = (innerslotmax / 2);

    /// Debug parameter: Enables expensive and thorough checking of the B+ tree
    /// invariants after each insert/erase operation.
    static const bool selfverify = traits::selfverify;

    /// Debug parameter: Prints out lots of debug information about how the
    /// algorithms change the tree. Requires the header file to be compiled
    /// with BTREE_DEBUG and the key type must be std::ostream printable.
    static const bool debug = traits::debug;

private:
    // *** Node Classes for In-Memory Nodes

    /// The header structure of each node in-memory. This structure is extended
    /// by inner_node or leaf_node.
    struct node
    {
        /// Level in the b-tree, if level == 0 -> leaf node
        unsigned short level;

        /// Number of key slotuse use, so number of valid children or data
        /// pointers
        unsigned short slotuse;
        modelType model_type = modelType::GENERAL;
        // bool reverse = false;
        // u_int8_t right_move = 0;
        // Polynomial variable
        double fk[3] = {0};
        double fb[3] = {0};

        // int key_move_bits = 0;
        // size_t value_base = 0;
        // key_type model_max_key;
        // double fe = 0;
        // size_t rfa = 0;
        // size_t rfb = 0;
        uint16_t gap_ratio = 0;
        uint16_t insert_count = 0;
        uint16_t delete_count = 0;
        unsigned short model_slotuse;

        /// Delayed initialisation of constructed node
        inline node(const unsigned short l, const unsigned short s = 0)
            : level(l), slotuse(s)
        { }

        /// True if this is a leaf node
        inline bool    isleafnode() const
        {
            return (level == 0);
        }
    };

    /// Extended structure of a inner node in-memory. Contains only keys and no
    /// data items.
    struct inner_node : public node
    {
        /// Define an related allocator for the inner_node structs.
        typedef typename _Alloc::template rebind<inner_node>::other alloc_type;

        /// Keys of children or data pointers
        key_type slotkey[innerslotmax];

        /// Pointers to children
        node     * childid[innerslotmax + 1];
        // size_t ffa[innerslotmax + 1] = {0};
        // modelType model_type[innerslotmax + 1] = {modelType::GENERAL};

        /// Set variables to initial values
        inline inner_node(const unsigned short l)
            : node(l)
        { }

        /// Construction during restore from node top
        inline inner_node(const node& top)
            : node(top.level, top.slotuse)
        { }

        /// True if the node's slots are full
        inline bool isfull() const
        {
            return (node::slotuse == innerslotmax);
        }

        /// True if few used entries, less than half full
        inline bool isfew() const
        {
            return (node::slotuse <= mininnerslots);
        }

        /// True if node has too few entries
        inline bool isunderflow() const
        {
            return (node::slotuse < mininnerslots);
        }

        inline key_type minkey() const {
            return slotkey[0];
        }
        inline key_type maxkey() const {
            return slotkey[node::slotuse-1];
        }
    };

    /// Extended structure of a leaf node in memory. Contains pairs of keys and
    /// data items. Key and data slots are kept in separate arrays, because the
    /// key array is traversed very often compared to accessing the data items.
    struct leaf_node : public node
    {
        /// Define an related allocator for the leaf_node structs.
        typedef typename _Alloc::template rebind<leaf_node>::other alloc_type;

        /// Double linked list pointers to traverse the leaves
        leaf_node * prevleaf;

        /// Double linked list pointers to traverse the leaves
        leaf_node * nextleaf;

        /// Keys of children or data pointers
        key_type  slotkey[leafslotmax];

        /// Array of data
        data_type slotdata[used_as_set ? 1 : leafslotmax];

        /// Set variables to initial values
        inline leaf_node()
            : node(0), prevleaf(NULL), nextleaf(NULL)
        { }

        /// Construction during restore from node top
        inline leaf_node(const node& top)
            : node(top.level, top.slotuse), prevleaf(NULL), nextleaf(NULL)
        { }

        /// True if the node's slots are full
        inline bool isfull() const
        {
            return (node::slotuse == leafslotmax);
        }

        /// True if few used entries, less than half full
        inline bool isfew() const
        {
            return (node::slotuse <= minleafslots);
        }

        /// True if node has too few entries
        inline bool isunderflow() const
        {
            return (node::slotuse < minleafslots);
        }

        /// Set the (key,data) pair in slot. Overloaded function used by
        /// bulk_load().
        inline void set_slot(unsigned short slot, const pair_type& value)
        {
            BTREE_ASSERT(used_as_set == false);
            BTREE_ASSERT(slot < node::slotuse);
            slotkey[slot] = value.first;
            slotdata[slot] = value.second;
        }

        /// Set the key pair in slot. Overloaded function used by
        /// bulk_load().
        inline void set_slot(unsigned short slot, const key_type& key)
        {
            BTREE_ASSERT(used_as_set == true);
            BTREE_ASSERT(slot < node::slotuse);
            slotkey[slot] = key;
        }


        inline key_type minkey() const {
            return slotkey[0];
        }
        inline key_type maxkey() const {
            return slotkey[node::slotuse-1];
        }
    };

private:
    // *** Template Magic to Convert a pair or key/data types to a value_type

    /// For sets the second pair_type is an empty struct, so the value_type
    /// should only be the first.
    template <typename value_type, typename pair_type>
    struct btree_pair_to_value
    {
        /// Convert a fake pair type to just the first component
        inline value_type operator () (pair_type& p) const
        {
            return p.first;
        }
        /// Convert a fake pair type to just the first component
        inline value_type operator () (const pair_type& p) const
        {
            return p.first;
        }
    };

    /// For maps value_type is the same as the pair_type
    template <typename value_type>
    struct btree_pair_to_value<value_type, value_type>
    {
        /// Identity "convert" a real pair type to just the first component
        inline value_type operator () (pair_type& p) const
        {
            return p;
        }
        /// Identity "convert" a real pair type to just the first component
        inline value_type operator () (const pair_type& p) const
        {
            return p;
        }
    };

    /// Using template specialization select the correct converter used by the
    /// iterators
    typedef btree_pair_to_value<value_type, pair_type> pair_to_value_type;

public:
    // *** Iterators and Reverse Iterators

    class iterator;
    class const_iterator;
    class reverse_iterator;
    class const_reverse_iterator;

    /// STL-like iterator object for B+ tree items. The iterator points to a
    /// specific slot number in a leaf.
    class iterator
    {
    public:
        // *** Types

        /// The key type of the btree. Returned by key().
        typedef typename btree::key_type key_type;

        /// The data type of the btree. Returned by data().
        typedef typename btree::data_type data_type;

        /// The value type of the btree. Returned by operator*().
        typedef typename btree::value_type value_type;

        /// The pair type of the btree.
        typedef typename btree::pair_type pair_type;

        /// Reference to the value_type. STL required.
        typedef value_type& reference;

        /// Pointer to the value_type. STL required.
        typedef value_type* pointer;

        /// STL-magic iterator category
        typedef std::bidirectional_iterator_tag iterator_category;

        /// STL-magic
        typedef ptrdiff_t difference_type;

    private:
        // *** Members

        /// The currently referenced leaf node of the tree
        typename btree::leaf_node * currnode;

        /// Current key/data slot referenced
        unsigned short currslot;

        /// Friendly to the const_iterator, so it may access the two data items
        /// directly.
        friend class const_iterator;

        /// Also friendly to the reverse_iterator, so it may access the two
        /// data items directly.
        friend class reverse_iterator;

        /// Also friendly to the const_reverse_iterator, so it may access the
        /// two data items directly.
        friend class const_reverse_iterator;

        /// Also friendly to the base btree class, because erase_iter() needs
        /// to read the currnode and currslot values directly.
        friend class btree<key_type, data_type, value_type, key_compare,
                           traits, allow_duplicates, allocator_type, used_as_set>;

        /// Evil! A temporary value_type to STL-correctly deliver operator* and
        /// operator->
        mutable value_type temp_value;

        // The macro BTREE_FRIENDS can be used by outside class to access the B+
        // tree internals. This was added for wxBTreeDemo to be able to draw the
        // tree.
        BTREE_FRIENDS

    public:
        // *** Methods

        /// Default-Constructor of a mutable iterator
        inline iterator()
            : currnode(NULL), currslot(0)
        { }

        /// Initializing-Constructor of a mutable iterator
        inline iterator(typename btree::leaf_node* l, unsigned short s)
            : currnode(l), currslot(s)
        { }

        /// Copy-constructor from a reverse iterator
        inline iterator(const reverse_iterator& it) // NOLINT
            : currnode(it.currnode), currslot(it.currslot)
        { }

        /// Dereference the iterator, this is not a value_type& because key and
        /// value are not stored together
        inline reference operator * () const
        {
            temp_value = pair_to_value_type()(pair_type(key(), data()));
            return temp_value;
        }

        /// Dereference the iterator. Do not use this if possible, use key()
        /// and data() instead. The B+ tree does not stored key and data
        /// together.
        inline pointer operator -> () const
        {
            temp_value = pair_to_value_type()(pair_type(key(), data()));
            return &temp_value;
        }

        /// Key of the current slot
        inline const key_type & key() const
        {
            return currnode->slotkey[currslot];
        }

        /// Writable reference to the current data object
        inline data_type & data() const
        {
            return currnode->slotdata[used_as_set ? 0 : currslot];
        }

        /// Prefix++ advance the iterator to the next slot
        inline iterator& operator ++ ()
        {
            if (currslot + 1 < currnode->slotuse) {
                ++currslot;
            }
            else if (currnode->nextleaf != NULL) {
                currnode = currnode->nextleaf;
                currslot = 0;
            }
            else {
                // this is end()
                currslot = currnode->slotuse;
            }

            return *this;
        }

        /// Postfix++ advance the iterator to the next slot
        inline iterator operator ++ (int)
        {
            iterator tmp = *this;   // copy ourselves

            if (currslot + 1 < currnode->slotuse) {
                ++currslot;
            }
            else if (currnode->nextleaf != NULL) {
                currnode = currnode->nextleaf;
                currslot = 0;
            }
            else {
                // this is end()
                currslot = currnode->slotuse;
            }

            return tmp;
        }

        /// Prefix-- backstep the iterator to the last slot
        inline iterator& operator -- ()
        {
            if (currslot > 0) {
                --currslot;
            }
            else if (currnode->prevleaf != NULL) {
                currnode = currnode->prevleaf;
                currslot = currnode->slotuse - 1;
            }
            else {
                // this is begin()
                currslot = 0;
            }

            return *this;
        }

        /// Postfix-- backstep the iterator to the last slot
        inline iterator operator -- (int)
        {
            iterator tmp = *this;   // copy ourselves

            if (currslot > 0) {
                --currslot;
            }
            else if (currnode->prevleaf != NULL) {
                currnode = currnode->prevleaf;
                currslot = currnode->slotuse - 1;
            }
            else {
                // this is begin()
                currslot = 0;
            }

            return tmp;
        }

        /// Equality of iterators
        inline bool operator == (const iterator& x) const
        {
            return (x.currnode == currnode) && (x.currslot == currslot);
        }

        /// Inequality of iterators
        inline bool operator != (const iterator& x) const
        {
            return (x.currnode != currnode) || (x.currslot != currslot);
        }
    };

    /// STL-like read-only iterator object for B+ tree items. The iterator
    /// points to a specific slot number in a leaf.
    class const_iterator
    {
    public:
        // *** Types

        /// The key type of the btree. Returned by key().
        typedef typename btree::key_type key_type;

        /// The data type of the btree. Returned by data().
        typedef typename btree::data_type data_type;

        /// The value type of the btree. Returned by operator*().
        typedef typename btree::value_type value_type;

        /// The pair type of the btree.
        typedef typename btree::pair_type pair_type;

        /// Reference to the value_type. STL required.
        typedef const value_type& reference;

        /// Pointer to the value_type. STL required.
        typedef const value_type* pointer;

        /// STL-magic iterator category
        typedef std::bidirectional_iterator_tag iterator_category;

        /// STL-magic
        typedef ptrdiff_t difference_type;

    private:
        // *** Members

        /// The currently referenced leaf node of the tree
        const typename btree::leaf_node * currnode;

        /// Current key/data slot referenced
        unsigned short currslot;

        /// Friendly to the reverse_const_iterator, so it may access the two
        /// data items directly
        friend class const_reverse_iterator;

        /// Evil! A temporary value_type to STL-correctly deliver operator* and
        /// operator->
        mutable value_type temp_value;

        // The macro BTREE_FRIENDS can be used by outside class to access the B+
        // tree internals. This was added for wxBTreeDemo to be able to draw the
        // tree.
        BTREE_FRIENDS

    public:
        // *** Methods

        /// Default-Constructor of a const iterator
        inline const_iterator()
            : currnode(NULL), currslot(0)
        { }

        /// Initializing-Constructor of a const iterator
        inline const_iterator(const typename btree::leaf_node* l, unsigned short s)
            : currnode(l), currslot(s)
        { }

        /// Copy-constructor from a mutable iterator
        inline const_iterator(const iterator& it) // NOLINT
            : currnode(it.currnode), currslot(it.currslot)
        { }

        /// Copy-constructor from a mutable reverse iterator
        inline const_iterator(const reverse_iterator& it) // NOLINT
            : currnode(it.currnode), currslot(it.currslot)
        { }

        /// Copy-constructor from a const reverse iterator
        inline const_iterator(const const_reverse_iterator& it) // NOLINT
            : currnode(it.currnode), currslot(it.currslot)
        { }

        /// Dereference the iterator. Do not use this if possible, use key()
        /// and data() instead. The B+ tree does not stored key and data
        /// together.
        inline reference operator * () const
        {
            temp_value = pair_to_value_type()(pair_type(key(), data()));
            return temp_value;
        }

        /// Dereference the iterator. Do not use this if possible, use key()
        /// and data() instead. The B+ tree does not stored key and data
        /// together.
        inline pointer operator -> () const
        {
            temp_value = pair_to_value_type()(pair_type(key(), data()));
            return &temp_value;
        }

        /// Key of the current slot
        inline const key_type & key() const
        {
            return currnode->slotkey[currslot];
        }

        /// Read-only reference to the current data object
        inline const data_type & data() const
        {
            return currnode->slotdata[used_as_set ? 0 : currslot];
        }

        /// Prefix++ advance the iterator to the next slot
        inline const_iterator& operator ++ ()
        {
            if (currslot + 1 < currnode->slotuse) {
                ++currslot;
            }
            else if (currnode->nextleaf != NULL) {
                currnode = currnode->nextleaf;
                currslot = 0;
            }
            else {
                // this is end()
                currslot = currnode->slotuse;
            }

            return *this;
        }

        /// Postfix++ advance the iterator to the next slot
        inline const_iterator operator ++ (int)
        {
            const_iterator tmp = *this;   // copy ourselves

            if (currslot + 1 < currnode->slotuse) {
                ++currslot;
            }
            else if (currnode->nextleaf != NULL) {
                currnode = currnode->nextleaf;
                currslot = 0;
            }
            else {
                // this is end()
                currslot = currnode->slotuse;
            }

            return tmp;
        }

        /// Prefix-- backstep the iterator to the last slot
        inline const_iterator& operator -- ()
        {
            if (currslot > 0) {
                --currslot;
            }
            else if (currnode->prevleaf != NULL) {
                currnode = currnode->prevleaf;
                currslot = currnode->slotuse - 1;
            }
            else {
                // this is begin()
                currslot = 0;
            }

            return *this;
        }

        /// Postfix-- backstep the iterator to the last slot
        inline const_iterator operator -- (int)
        {
            const_iterator tmp = *this;   // copy ourselves

            if (currslot > 0) {
                --currslot;
            }
            else if (currnode->prevleaf != NULL) {
                currnode = currnode->prevleaf;
                currslot = currnode->slotuse - 1;
            }
            else {
                // this is begin()
                currslot = 0;
            }

            return tmp;
        }

        /// Equality of iterators
        inline bool operator == (const const_iterator& x) const
        {
            return (x.currnode == currnode) && (x.currslot == currslot);
        }

        /// Inequality of iterators
        inline bool operator != (const const_iterator& x) const
        {
            return (x.currnode != currnode) || (x.currslot != currslot);
        }
    };

    /// STL-like mutable reverse iterator object for B+ tree items. The
    /// iterator points to a specific slot number in a leaf.
    class reverse_iterator
    {
    public:
        // *** Types

        /// The key type of the btree. Returned by key().
        typedef typename btree::key_type key_type;

        /// The data type of the btree. Returned by data().
        typedef typename btree::data_type data_type;

        /// The value type of the btree. Returned by operator*().
        typedef typename btree::value_type value_type;

        /// The pair type of the btree.
        typedef typename btree::pair_type pair_type;

        /// Reference to the value_type. STL required.
        typedef value_type& reference;

        /// Pointer to the value_type. STL required.
        typedef value_type* pointer;

        /// STL-magic iterator category
        typedef std::bidirectional_iterator_tag iterator_category;

        /// STL-magic
        typedef ptrdiff_t difference_type;

    private:
        // *** Members

        /// The currently referenced leaf node of the tree
        typename btree::leaf_node * currnode;

        /// One slot past the current key/data slot referenced.
        unsigned short currslot;

        /// Friendly to the const_iterator, so it may access the two data items
        /// directly
        friend class iterator;

        /// Also friendly to the const_iterator, so it may access the two data
        /// items directly
        friend class const_iterator;

        /// Also friendly to the const_iterator, so it may access the two data
        /// items directly
        friend class const_reverse_iterator;

        /// Evil! A temporary value_type to STL-correctly deliver operator* and
        /// operator->
        mutable value_type temp_value;

        // The macro BTREE_FRIENDS can be used by outside class to access the B+
        // tree internals. This was added for wxBTreeDemo to be able to draw the
        // tree.
        BTREE_FRIENDS

    public:
        // *** Methods

        /// Default-Constructor of a reverse iterator
        inline reverse_iterator()
            : currnode(NULL), currslot(0)
        { }

        /// Initializing-Constructor of a mutable reverse iterator
        inline reverse_iterator(typename btree::leaf_node* l, unsigned short s)
            : currnode(l), currslot(s)
        { }

        /// Copy-constructor from a mutable iterator
        inline reverse_iterator(const iterator& it) // NOLINT
            : currnode(it.currnode), currslot(it.currslot)
        { }

        /// Dereference the iterator, this is not a value_type& because key and
        /// value are not stored together
        inline reference operator * () const
        {
            BTREE_ASSERT(currslot > 0);
            temp_value = pair_to_value_type()(pair_type(key(), data()));
            return temp_value;
        }

        /// Dereference the iterator. Do not use this if possible, use key()
        /// and data() instead. The B+ tree does not stored key and data
        /// together.
        inline pointer operator -> () const
        {
            BTREE_ASSERT(currslot > 0);
            temp_value = pair_to_value_type()(pair_type(key(), data()));
            return &temp_value;
        }

        /// Key of the current slot
        inline const key_type & key() const
        {
            BTREE_ASSERT(currslot > 0);
            return currnode->slotkey[currslot - 1];
        }

        /// Writable reference to the current data object
        inline data_type & data() const
        {
            BTREE_ASSERT(currslot > 0);
            return currnode->slotdata[used_as_set ? 0 : currslot - 1];
        }

        /// Prefix++ advance the iterator to the next slot
        inline reverse_iterator& operator ++ ()
        {
            if (currslot > 1) {
                --currslot;
            }
            else if (currnode->prevleaf != NULL) {
                currnode = currnode->prevleaf;
                currslot = currnode->slotuse;
            }
            else {
                // this is begin() == rend()
                currslot = 0;
            }

            return *this;
        }

        /// Postfix++ advance the iterator to the next slot
        inline reverse_iterator operator ++ (int)
        {
            reverse_iterator tmp = *this;   // copy ourselves

            if (currslot > 1) {
                --currslot;
            }
            else if (currnode->prevleaf != NULL) {
                currnode = currnode->prevleaf;
                currslot = currnode->slotuse;
            }
            else {
                // this is begin() == rend()
                currslot = 0;
            }

            return tmp;
        }

        /// Prefix-- backstep the iterator to the last slot
        inline reverse_iterator& operator -- ()
        {
            if (currslot < currnode->slotuse) {
                ++currslot;
            }
            else if (currnode->nextleaf != NULL) {
                currnode = currnode->nextleaf;
                currslot = 1;
            }
            else {
                // this is end() == rbegin()
                currslot = currnode->slotuse;
            }

            return *this;
        }

        /// Postfix-- backstep the iterator to the last slot
        inline reverse_iterator operator -- (int)
        {
            reverse_iterator tmp = *this;   // copy ourselves

            if (currslot < currnode->slotuse) {
                ++currslot;
            }
            else if (currnode->nextleaf != NULL) {
                currnode = currnode->nextleaf;
                currslot = 1;
            }
            else {
                // this is end() == rbegin()
                currslot = currnode->slotuse;
            }

            return tmp;
        }

        /// Equality of iterators
        inline bool operator == (const reverse_iterator& x) const
        {
            return (x.currnode == currnode) && (x.currslot == currslot);
        }

        /// Inequality of iterators
        inline bool operator != (const reverse_iterator& x) const
        {
            return (x.currnode != currnode) || (x.currslot != currslot);
        }
    };

    /// STL-like read-only reverse iterator object for B+ tree items. The
    /// iterator points to a specific slot number in a leaf.
    class const_reverse_iterator
    {
    public:
        // *** Types

        /// The key type of the btree. Returned by key().
        typedef typename btree::key_type key_type;

        /// The data type of the btree. Returned by data().
        typedef typename btree::data_type data_type;

        /// The value type of the btree. Returned by operator*().
        typedef typename btree::value_type value_type;

        /// The pair type of the btree.
        typedef typename btree::pair_type pair_type;

        /// Reference to the value_type. STL required.
        typedef const value_type& reference;

        /// Pointer to the value_type. STL required.
        typedef const value_type* pointer;

        /// STL-magic iterator category
        typedef std::bidirectional_iterator_tag iterator_category;

        /// STL-magic
        typedef ptrdiff_t difference_type;

    private:
        // *** Members

        /// The currently referenced leaf node of the tree
        const typename btree::leaf_node * currnode;

        /// One slot past the current key/data slot referenced.
        unsigned short currslot;

        /// Friendly to the const_iterator, so it may access the two data items
        /// directly.
        friend class reverse_iterator;

        /// Evil! A temporary value_type to STL-correctly deliver operator* and
        /// operator->
        mutable value_type temp_value;

        // The macro BTREE_FRIENDS can be used by outside class to access the B+
        // tree internals. This was added for wxBTreeDemo to be able to draw the
        // tree.
        BTREE_FRIENDS

    public:
        // *** Methods

        /// Default-Constructor of a const reverse iterator
        inline const_reverse_iterator()
            : currnode(NULL), currslot(0)
        { }

        /// Initializing-Constructor of a const reverse iterator
        inline const_reverse_iterator(const typename btree::leaf_node* l, unsigned short s)
            : currnode(l), currslot(s)
        { }

        /// Copy-constructor from a mutable iterator
        inline const_reverse_iterator(const iterator& it) // NOLINT
            : currnode(it.currnode), currslot(it.currslot)
        { }

        /// Copy-constructor from a const iterator
        inline const_reverse_iterator(const const_iterator& it) // NOLINT
            : currnode(it.currnode), currslot(it.currslot)
        { }

        /// Copy-constructor from a mutable reverse iterator
        inline const_reverse_iterator(const reverse_iterator& it) // NOLINT
            : currnode(it.currnode), currslot(it.currslot)
        { }

        /// Dereference the iterator. Do not use this if possible, use key()
        /// and data() instead. The B+ tree does not stored key and data
        /// together.
        inline reference operator * () const
        {
            BTREE_ASSERT(currslot > 0);
            temp_value = pair_to_value_type()(pair_type(key(), data()));
            return temp_value;
        }

        /// Dereference the iterator. Do not use this if possible, use key()
        /// and data() instead. The B+ tree does not stored key and data
        /// together.
        inline pointer operator -> () const
        {
            BTREE_ASSERT(currslot > 0);
            temp_value = pair_to_value_type()(pair_type(key(), data()));
            return &temp_value;
        }

        /// Key of the current slot
        inline const key_type & key() const
        {
            BTREE_ASSERT(currslot > 0);
            return currnode->slotkey[currslot - 1];
        }

        /// Read-only reference to the current data object
        inline const data_type & data() const
        {
            BTREE_ASSERT(currslot > 0);
            return currnode->slotdata[used_as_set ? 0 : currslot - 1];
        }

        /// Prefix++ advance the iterator to the previous slot
        inline const_reverse_iterator& operator ++ ()
        {
            if (currslot > 1) {
                --currslot;
            }
            else if (currnode->prevleaf != NULL) {
                currnode = currnode->prevleaf;
                currslot = currnode->slotuse;
            }
            else {
                // this is begin() == rend()
                currslot = 0;
            }

            return *this;
        }

        /// Postfix++ advance the iterator to the previous slot
        inline const_reverse_iterator operator ++ (int)
        {
            const_reverse_iterator tmp = *this;   // copy ourselves

            if (currslot > 1) {
                --currslot;
            }
            else if (currnode->prevleaf != NULL) {
                currnode = currnode->prevleaf;
                currslot = currnode->slotuse;
            }
            else {
                // this is begin() == rend()
                currslot = 0;
            }

            return tmp;
        }

        /// Prefix-- backstep the iterator to the next slot
        inline const_reverse_iterator& operator -- ()
        {
            if (currslot < currnode->slotuse) {
                ++currslot;
            }
            else if (currnode->nextleaf != NULL) {
                currnode = currnode->nextleaf;
                currslot = 1;
            }
            else {
                // this is end() == rbegin()
                currslot = currnode->slotuse;
            }

            return *this;
        }

        /// Postfix-- backstep the iterator to the next slot
        inline const_reverse_iterator operator -- (int)
        {
            const_reverse_iterator tmp = *this;   // copy ourselves

            if (currslot < currnode->slotuse) {
                ++currslot;
            }
            else if (currnode->nextleaf != NULL) {
                currnode = currnode->nextleaf;
                currslot = 1;
            }
            else {
                // this is end() == rbegin()
                currslot = currnode->slotuse;
            }

            return tmp;
        }

        /// Equality of iterators
        inline bool operator == (const const_reverse_iterator& x) const
        {
            return (x.currnode == currnode) && (x.currslot == currslot);
        }

        /// Inequality of iterators
        inline bool operator != (const const_reverse_iterator& x) const
        {
            return (x.currnode != currnode) || (x.currslot != currslot);
        }
    };

public:
    // *** Small Statistics Structure

    /** A small struct containing basic statistics about the B+ tree. It can be
     * fetched using get_stats(). */
    struct tree_stats
    {
        /// Number of items in the B+ tree
        size_type                   itemcount;

        /// Number of leaves in the B+ tree
        size_type                   leaves;

        /// Number of inner nodes in the B+ tree
        size_type                   innernodes;

        /// Base B+ tree parameter: The number of key/data slots in each leaf
        static const unsigned short leafslots = self_type::leafslotmax;

        /// Base B+ tree parameter: The number of key slots in each inner node.
        static const unsigned short innerslots = self_type::innerslotmax;

        /// Zero initialized
        inline tree_stats()
            : itemcount(0),
              leaves(0), innernodes(0)
        { }

        /// Return the total number of nodes
        inline size_type            nodes() const
        {
            return innernodes + leaves;
        }

        /// Return the average fill of leaves
        inline double               avgfill_leaves() const
        {
            return static_cast<double>(itemcount) / (leaves * leafslots);
        }
    };

private:
    // *** Tree Object Data Members

    /// Pointer to the B+ tree's root node, either leaf or inner node
    node* m_root;

    /// Pointer to first leaf in the double linked leaf chain
    leaf_node* m_headleaf;

    /// Pointer to last leaf in the double linked leaf chain
    leaf_node* m_tailleaf;

    /// Other small statistics about the B+ tree
    tree_stats m_stats;

    /// Key comparison object. More comparison functions are generated from
    /// this < relation.
    key_compare m_key_less;

    /// Memory allocator.
    allocator_type m_allocator;

public:
    // *** Constructors and Destructor

    /// Default constructor initializing an empty B+ tree with the standard key
    /// comparison function
    explicit inline btree(const allocator_type& alloc = allocator_type())
        : m_root(NULL), m_headleaf(NULL), m_tailleaf(NULL), m_allocator(alloc)
    { }

    /// Constructor initializing an empty B+ tree with a special key
    /// comparison object
    explicit inline btree(const key_compare& kcf,
                          const allocator_type& alloc = allocator_type())
        : m_root(NULL), m_headleaf(NULL), m_tailleaf(NULL),
          m_key_less(kcf), m_allocator(alloc)
    { }

    /// Constructor initializing a B+ tree with the range [first,last). The
    /// range need not be sorted. To create a B+ tree from a sorted range, use
    /// bulk_load().
    template <class InputIterator>
    inline btree(InputIterator first, InputIterator last,
                 const allocator_type& alloc = allocator_type())
        : m_root(NULL), m_headleaf(NULL), m_tailleaf(NULL), m_allocator(alloc)
    {
        insert(first, last);
    }

    /// Constructor initializing a B+ tree with the range [first,last) and a
    /// special key comparison object.  The range need not be sorted. To create
    /// a B+ tree from a sorted range, use bulk_load().
    template <class InputIterator>
    inline btree(InputIterator first, InputIterator last, const key_compare& kcf,
                 const allocator_type& alloc = allocator_type())
        : m_root(NULL), m_headleaf(NULL), m_tailleaf(NULL),
          m_key_less(kcf), m_allocator(alloc)
    {
        insert(first, last);
    }

    /// Frees up all used B+ tree memory pages
    inline ~btree()
    {
        clear();
    }

    /// Fast swapping of two identical B+ tree objects.
    void swap(self_type& from)
    {
        std::swap(m_root, from.m_root);
        std::swap(m_headleaf, from.m_headleaf);
        std::swap(m_tailleaf, from.m_tailleaf);
        std::swap(m_stats, from.m_stats);
        std::swap(m_key_less, from.m_key_less);
        std::swap(m_allocator, from.m_allocator);
    }

public:
    // *** Key and Value Comparison Function Objects

    /// Function class to compare value_type objects. Required by the STL
    class value_compare
    {
    protected:
        /// Key comparison function from the template parameter
        key_compare key_comp;

        /// Constructor called from btree::value_comp()
        inline explicit value_compare(key_compare kc)
            : key_comp(kc)
        { }

        /// Friendly to the btree class so it may call the constructor
        friend class btree<key_type, data_type, value_type, key_compare,
                           traits, allow_duplicates, allocator_type, used_as_set>;

    public:
        /// Function call "less"-operator resulting in true if x < y.
        inline bool operator () (const value_type& x, const value_type& y) const
        {
            return key_comp(x.first, y.first);
        }
    };

    /// Constant access to the key comparison object sorting the B+ tree
    inline key_compare key_comp() const
    {
        return m_key_less;
    }

    /// Constant access to a constructed value_type comparison object. Required
    /// by the STL
    inline value_compare value_comp() const
    {
        return value_compare(m_key_less);
    }

private:
    // *** Convenient Key Comparison Functions Generated From key_less

    /// True if a < b ? "constructed" from m_key_less()
    inline bool key_less(const key_type& a, const key_type& b) const
    {
        return m_key_less(a, b);
    }

    /// True if a <= b ? constructed from key_less()
    inline bool key_lessequal(const key_type& a, const key_type& b) const
    {
        return !m_key_less(b, a);
    }

    /// True if a > b ? constructed from key_less()
    inline bool key_greater(const key_type& a, const key_type& b) const
    {
        return m_key_less(b, a);
    }

    /// True if a >= b ? constructed from key_less()
    inline bool key_greaterequal(const key_type& a, const key_type& b) const
    {
        return !m_key_less(a, b);
    }

    /// True if a == b ? constructed from key_less(). This requires the <
    /// relation to be a total order, otherwise the B+ tree cannot be sorted.
    inline bool key_equal(const key_type& a, const key_type& b) const
    {
        return !m_key_less(a, b) && !m_key_less(b, a);
    }

public:
    // *** Allocators

    /// Return the base node allocator provided during construction.
    allocator_type get_allocator() const
    {
        return m_allocator;
    }

private:
    // *** Node Object Allocation and Deallocation Functions

    /// Return an allocator for leaf_node objects
    typename leaf_node::alloc_type leaf_node_allocator()
    {
        return typename leaf_node::alloc_type(m_allocator);
    }

    /// Return an allocator for inner_node objects
    typename inner_node::alloc_type inner_node_allocator()
    {
        return typename inner_node::alloc_type(m_allocator);
    }

    /// Allocate and initialize a leaf node
    inline leaf_node * allocate_leaf()
    {
        leaf_node* n = new (leaf_node_allocator().allocate(1))
                       leaf_node();
        m_stats.leaves++;
        return n;
    }

    /// Allocate and initialize an inner node
    inline inner_node * allocate_inner(unsigned short level)
    {
        inner_node* n = new (inner_node_allocator().allocate(1))
                        inner_node(level);
        m_stats.innernodes++;
        return n;
    }

    /// Correctly free either inner or leaf node, destructs all contained key
    /// and value objects
    inline void free_node(node* n)
    {
        if (n->isleafnode()) {
            leaf_node* ln = static_cast<leaf_node*>(n);
            typename leaf_node::alloc_type a(leaf_node_allocator());
            a.destroy(ln);
            a.deallocate(ln, 1);
            m_stats.leaves--;
        }
        else {
            inner_node* in = static_cast<inner_node*>(n);
            typename inner_node::alloc_type a(inner_node_allocator());
            a.destroy(in);
            a.deallocate(in, 1);
            m_stats.innernodes--;
        }
    }

    /// Convenient template function for conditional copying of slotdata. This
    /// should be used instead of std::copy for all slotdata manipulations.
    template <class InputIterator, class OutputIterator>
    static OutputIterator data_copy(InputIterator first, InputIterator last,
                                    OutputIterator result)
    {
        if (used_as_set) return result; // no operation
        else return std::copy(first, last, result);
    }

    /// Convenient template function for conditional copying of slotdata. This
    /// should be used instead of std::copy for all slotdata manipulations.
    template <class InputIterator, class OutputIterator>
    static OutputIterator data_copy_backward(InputIterator first, InputIterator last,
                                             OutputIterator result)
    {
        if (used_as_set) return result; // no operation
        else return std::copy_backward(first, last, result);
    }

public:
    // *** Fast Destruction of the B+ Tree

    /// Frees all key/data pairs and all nodes of the tree
    void clear()
    {
        if (m_root)
        {
            clear_recursive(m_root);
            free_node(m_root);

            m_root = NULL;
            m_headleaf = m_tailleaf = NULL;

            m_stats = tree_stats();
        }

        BTREE_ASSERT(m_stats.itemcount == 0);
    }

private:
    /// Recursively free up nodes
    void clear_recursive(node* n)
    {
        if (n->isleafnode())
        {
            leaf_node* leafnode = static_cast<leaf_node*>(n);

            for (unsigned int slot = 0; slot < leafnode->slotuse; ++slot)
            {
                // data objects are deleted by leaf_node's destructor
            }
        }
        else
        {
            inner_node* innernode = static_cast<inner_node*>(n);

            for (unsigned short slot = 0; slot < innernode->slotuse + 1; ++slot)
            {
                clear_recursive(innernode->childid[slot]);
                free_node(innernode->childid[slot]);
            }
        }
    }

public:
    // *** STL Iterator Construction Functions

    /// Constructs a read/data-write iterator that points to the first slot in
    /// the first leaf of the B+ tree.
    inline iterator begin()
    {
        return iterator(m_headleaf, 0);
    }

    /// Constructs a read/data-write iterator that points to the first invalid
    /// slot in the last leaf of the B+ tree.
    inline iterator end()
    {
        return iterator(m_tailleaf, m_tailleaf ? m_tailleaf->slotuse : 0);
    }

    /// Constructs a read-only constant iterator that points to the first slot
    /// in the first leaf of the B+ tree.
    inline const_iterator begin() const
    {
        return const_iterator(m_headleaf, 0);
    }

    /// Constructs a read-only constant iterator that points to the first
    /// invalid slot in the last leaf of the B+ tree.
    inline const_iterator end() const
    {
        return const_iterator(m_tailleaf, m_tailleaf ? m_tailleaf->slotuse : 0);
    }

    /// Constructs a read/data-write reverse iterator that points to the first
    /// invalid slot in the last leaf of the B+ tree. Uses STL magic.
    inline reverse_iterator rbegin()
    {
        return reverse_iterator(end());
    }

    /// Constructs a read/data-write reverse iterator that points to the first
    /// slot in the first leaf of the B+ tree. Uses STL magic.
    inline reverse_iterator rend()
    {
        return reverse_iterator(begin());
    }

    /// Constructs a read-only reverse iterator that points to the first
    /// invalid slot in the last leaf of the B+ tree. Uses STL magic.
    inline const_reverse_iterator rbegin() const
    {
        return const_reverse_iterator(end());
    }

    /// Constructs a read-only reverse iterator that points to the first slot
    /// in the first leaf of the B+ tree. Uses STL magic.
    inline const_reverse_iterator rend() const
    {
        return const_reverse_iterator(begin());
    }

private:
    // *** B+ Tree Node Binary Search Functions

    /// Searches for the first key in the node n greater or equal to key. Uses
    /// binary search with an optional linear self-verification. This is a
    /// template function, because the slotkey array is located at different
    /// places in leaf_node and inner_node.
    template <typename node_type>
    inline int find_lower(const node_type* n, const key_type& key) const
    {
#ifdef LEVEL_COUNT_TIME
        auto currentTime1 = std::chrono::high_resolution_clock::now();
#endif
        // if (sizeof(n->slotkey) > traits::binsearch_threshold)
        if (n->slotuse > 32)
        {
            // std::cout << "zou le bingary \n";
            // std::cout << traits::binsearch_threshold <<"zou le bingary \n";
            if (n->slotuse == 0) return 0;

            int lo = 0, hi = n->slotuse;
            if(n->slotkey[0] > key) return 0;
            if(n->slotkey[hi-1] < key) return hi;


            while (lo < hi)
            {
                int mid = (lo + hi) >> 1;

                if (key_lessequal(key, n->slotkey[mid])) {
                    hi = mid;     // key <= mid
                }
                else {
                    lo = mid + 1; // key > mid
                }
            }

            BTREE_PRINT("btree::find_lower: on " << n << " key " << key << " -> " << lo << " / " << hi);

            // verify result using simple linear search
            if (selfverify)
            {
                int i = 0;
                while (i < n->slotuse && key_less(n->slotkey[i], key)) ++i;

                BTREE_PRINT("btree::find_lower: testfind: " << i);
                BTREE_ASSERT(i == lo);
            }
#ifdef LEVEL_COUNT_TIME
        auto currentTime2 = std::chrono::high_resolution_clock::now();
        auto nanoseconds1 = std::chrono::duration_cast<std::chrono::nanoseconds>(currentTime1.time_since_epoch()).count();
        auto nanoseconds2 = std::chrono::duration_cast<std::chrono::nanoseconds>(currentTime2.time_since_epoch()).count();
        level_delay[btree_level] +=  (nanoseconds2 - nanoseconds1);
#endif
       
            return lo;
        }
        else // for nodes <= binsearch_threshold do linear search.
        {
            // std::cout << "zou le line \n";
            int lo = 0;
            while (lo < n->slotuse && key_less(n->slotkey[lo], key)) ++lo;
#ifdef LEVEL_COUNT_TIME
        auto currentTime2 = std::chrono::high_resolution_clock::now();
        auto nanoseconds1 = std::chrono::duration_cast<std::chrono::nanoseconds>(currentTime1.time_since_epoch()).count();
        auto nanoseconds2 = std::chrono::duration_cast<std::chrono::nanoseconds>(currentTime2.time_since_epoch()).count();
        level_delay[btree_level] +=  (nanoseconds2 - nanoseconds1);
#endif
       
            return lo;
        }

 

    }

    template <typename node_type>
    inline int binary_search(const node_type* n,int lo,int hi,const key_type& key){


        while (lo < hi)
        {
            int mid = (lo + hi) >> 1;

            if (key_lessequal(key, n->slotkey[mid])) {
                hi = mid;     // key <= mid
            }
            else {
                lo = mid + 1; // key > mid
            }
        }

        return lo;


    }



    // :
    
    // 
    int getSecond(int a,int b,int c){
        int max = a > b ? a : b;
        max = max > c ? max : c;
        int min = a < b ? a: b;
        min = min < c ? min : c;
        int second = a + b + c - max - min;
        return second;
    }

    template <typename node_type>
    inline int find_lower_liner_x(const node_type* n, const key_type& key )
    {

        if(n->model_type == modelType::GENERAL){
            return find_lower(n, key);
        }

#ifdef LINECOUNT_TIME
        auto currentTime1 = std::chrono::high_resolution_clock::now();
#endif
        if (n->slotuse == 0) return 0;
        int lo = 0, hi = n->slotuse;
        int pre_target,point;
        int pt0,pt1,pt2;

#ifdef L0_TIME
        auto currentTime1 = std::chrono::high_resolution_clock::now();
#endif

        pt0 = static_cast<int>(n->fk[0] * (key) + n->fb[0]);
        pt1 = static_cast<int>(n->fk[1] * (key) + n->fb[1]);
        pt2 = static_cast<int>(n->fk[2] * (key) + n->fb[2]);

        // std::cout << n->fk[0] << " " << n->fk[1] << " " << n->fk[2] << " \n";
        // std::cout << n->fb[0] << " " << n->fb[1] << " " << n->fb[2] << " \n";
        // std::cout << pt0 << " " << pt1 << " " << pt2 << " \n";

        switch (n->model_type)
        {
        case modelType::LINE:
            pre_target = pt0;
            break;
        
        case modelType::SX:
            pre_target = getSecond(pt0,pt1,pt2);
            break;
        
        case modelType::AO:
            pre_target = std::max(std::max(pt0,pt1),pt2);
            break;
        
        case modelType::TU:
            pre_target = std::min(std::min(pt0,pt1),pt2);
            break;
        
        default:
            pre_target = pt0;
            break;
        }

        point = pre_target = std::min(std::max(pre_target,lo),hi-1);

        if(n->slotkey[point] < key){

            while (point < hi && key_less(n->slotkey[point], key)) {
                point++;
            }
        }else{
            while (lo <= point && key_greaterequal(n->slotkey[point], key)) {
                point--;
            }
            point++;
        }
        // std::cout << pre_target << " "<<point<< "\n";
#ifdef L0_TIME
        auto currentTime2 = std::chrono::high_resolution_clock::now();
        auto nanoseconds1 = std::chrono::duration_cast<std::chrono::nanoseconds>(currentTime1.time_since_epoch()).count();
        auto nanoseconds2 = std::chrono::duration_cast<std::chrono::nanoseconds>(currentTime2.time_since_epoch()).count();
        exec_times[btree_level] +=  (nanoseconds2 - nanoseconds1);
        exec_counts[btree_level]++;
#endif

#ifdef LINECOUNT_TIME
        auto currentTime2 = std::chrono::high_resolution_clock::now();
        auto nanoseconds1 = std::chrono::duration_cast<std::chrono::nanoseconds>(currentTime1.time_since_epoch()).count();
        auto nanoseconds2 = std::chrono::duration_cast<std::chrono::nanoseconds>(currentTime2.time_since_epoch()).count();
        exec_times[0] +=  (nanoseconds2 - nanoseconds1);
        exec_counts[0]++;
#endif


#ifdef COUNT_GAP
        int gap = abs(pre_target-point) ;
        gaps[btree_level] += gap;
        gaps_count[btree_level]++;
#endif
        return point;

    }


    template<typename T>
    void cout_nodeinfo(const T* n) const{
        int x4 = n->slotuse - 1;
        int x2 = x4 >> 1;
        int x1 = x2 >> 1;
        int x3 = x2 + x1;
        int x0 = 0;

        // 4
        auto y0 = static_cast<double>(n->slotkey[x0]);
        auto y1 = static_cast<double>(n->slotkey[x1]);
        auto y2 = static_cast<double>(n->slotkey[x2]);
        auto y3 = static_cast<double>(n->slotkey[x3]);
        auto y4 = static_cast<double>(n->slotkey[x4]);

        int m0 = (x1 + x0)>>1;
        int m1 = (x2 + x1)>>1;
        int m2 = (x3 + x2)>>1;
        int m3 = (x4 + x3)>>1;

        auto my0 = static_cast<double>(n->slotkey[m0]);
        auto my1 = static_cast<double>(n->slotkey[m1]);
        auto my2 = static_cast<double>(n->slotkey[m2]);
        auto my3 = static_cast<double>(n->slotkey[m3]);

        // k
        double k0 = ((y1-y0) / (x1 - x0) + (my0-y0)/(m0-x0))/2;
        double k1 = ((y2-y1) / (x2 - x1) + (my1-y1)/(m1-x1))/2;
        double k2 = ((y3-y2) / (x3 - x2) + (my2-y2)/(m2-x2))/2;
        double k3 = ((y4-y3) / (x4 - x3) + (my3-y3)/(m3-x3))/2;

        // double fa = (x4-x0) / (y4-0);
        double left_kk  = k1-k0>0 ? k1/k0-1 : -k0/k1+1;
        double mid_kk   = k2-k1>0 ? k2/k1-1 : -k1/k2+1;
        double right_kk = k3-k2>0 ? k3/k2-1 : -k2/k3+1;
        std::cout << "k0-k3 " << k0 << " " << k1 << " " << k2 << " " << k3 << " | ";
        std::cout << "kk " << left_kk << " " << mid_kk << " " << right_kk << " | ";
        std::cout << "data_is ";
        for(int i=0;i<n->slotuse;i++){
            std::cout << n->slotkey[i] << ",";
        }
        std::cout << "\n";
    }

    template<typename T>
    int  check_fitting(T* n, size_t & line_err, size_t & errs){
        int len = n->slotuse;
        for(int i=0;i<len;i++){
            size_t e = n->slotkey[i];
            int site1 = n->fa * e + n->fd + n->fb * sin((e - n->fe) * n->fc  );
            // int site1 = n->fa * e + n->fd;
            int site2 = (n->fa * e) + n->fd;
            int site3 = find_lower(n,e);
            line_err += abs(site2-site3);
            errs += abs(site1-site3);
        }

        line_err /= len;
        errs /= len;

        return 0;
    }

    size_t get_lt1024(size_t a, int& i){
        size_t tmp = a;
        i = 0;
        while(tmp >> 8){
            tmp >>= 8;
            i+=8;
        }
        while(tmp >> 1){
            tmp >>=1;
            i++;
        }

        return a >> (1-10 > 0 ? i-10 : 0);

    }

    int get_first_1_site(size_t a){
        size_t tmp = a;
        int i = 0;
        while(tmp >> 8){
            tmp >>= 8;
            i+=8;
        }
        while(tmp >> 1){
            tmp >>=1;
            i++;
        }

        return i;

    }


    inline bool compute_integrate(double k1,double k2, double b1, double b2, int x1, int x2,double& up,double& down){
        if(x1>x2) return 0;
        double sum=0;
        double jx;

        jx = (b1-b2)/(k2-k1);
        if(jx > x1 && jx < x2){
            sum = (0.5*(k2-k1)*jx*jx  + (b2-b1)*jx) - (0.5*(k2-k1)*x1*x1  + (b2-b1)*x1);
            sum > 0 ? up = sum : down = -sum;
            sum = (0.5*(k2-k1)*x2*x2  + (b2-b1)*x2) - (0.5*(k2-k1)*jx*jx  + (b2-b1)*jx);
            sum > 0 ? up += sum : down += -sum;
        }else{
            sum = (0.5*(k2-k1)*x2*x2  + (b2-b1)*x2) - (0.5*(k2-k1)*x1*x1  + (b2-b1)*x1);
            sum>0 ? up = sum : down = -sum;
        }

        return true;

    }



    // generate duoxiangshi model
    template<typename T>
    inline bool generate_func_model(T* n){
        return node_training(n);
    }

    double meaning_distance(std::vector<double>& fa, std::vector<double>& fb, std::vector<double>& keys, std::vector<double>& sites, int begin, int end){
        double k,b,up=0,down=0,sum_up=0,sum_dowm=0;
        k = (keys[end] - keys[begin]) / (sites[end] - sites[begin]);
        b = keys[begin] - k * sites[begin];
        for(int i=begin;i<end;i++){
            compute_integrate(k, fa[i], b, fb[i], sites[i], sites[i+1], up, down);
            sum_dowm+=down;
            sum_up+=up;
        } 
        return sum_up + sum_dowm;
    }

    // generate duoxiangshi model
    template<typename T>
    bool node_training(T* n){
        // sure s1 != 0, define 5 site for compute k.


        int hi,lo,ele_gap,ele_num;
        double up_sum=0,down_sum=0,k=0,b=0,errs=0,fa=0,fb=0;
        hi = n->slotuse-1;
        lo = 0;

        if(n->slotuse < 64) {
            n->model_type = modelType::LINE;
            n->fk[0] = static_cast<double>(hi - lo) / static_cast<double>(n->slotkey[hi] - n->slotkey[lo]);
            n->fb[0] = lo - n->fk[0] * n->slotkey[lo];
            return true;
        }

        ele_gap = 16;
        ele_num = hi/ele_gap+1;
        std::vector<double> keys;
        std::vector<double> sites;
        std::vector<double> ka(ele_num-1);
        std::vector<double> kb(ele_num-1);

        for(int i=0;i<hi;i+=ele_gap){
            keys.push_back(static_cast<double>(n->slotkey[i]));
            sites.push_back(static_cast<double>(i));
        }

        for(int i=0;i<ele_num-1;i++){
            ka[i] = (keys[i+1] - keys[i]) / (sites[i+1] - sites[i]);
            kb[i] = keys[i] - ka[i] * sites[i];
        }

        k = (keys[ele_num-1] - keys[0]) / (sites[ele_num-1] - sites[0]);
        b = keys[0] - k * sites[0];

        for(int i=0;i<ele_num-1;i++){
            double up=0,down=0;
            compute_integrate(k, ka[i], b, kb[i], sites[i], sites[i+1], up, down);
            up_sum+=up; down_sum+=down;
        }


        // array sites
        int x4 = n->slotuse - 1;
        int x2 = x4 >> 1;
        int x1 = x2 >> 1;
        int x3 = x2 + x1;
        int x0 = 0;

        auto y0 = static_cast<double>(n->slotkey[x0]);
        auto y1 = static_cast<double>(n->slotkey[x1]);
        auto y2 = static_cast<double>(n->slotkey[x2]);
        auto y3 = static_cast<double>(n->slotkey[x3]);
        auto y4 = static_cast<double>(n->slotkey[x4]);

        double k0 = (y1-y0) / (x1 - x0);
        double k1 = (y2-y1) / (x2 - x1);
        double k2 = (y3-y2) / (x3 - x2);
        double k3 = (y4-y3) / (x4 - x3);

        fa = (sites[sites.size()-1] - sites[0]) / (keys[keys.size()-1] - keys[0]);
        fb = sites[0] - fa * keys[0];
        // std::cout << fa << " " << fb << "\n";
        errs = (up_sum + down_sum) / (keys[ele_num-1] - keys[0]);

        n->model_type = modelType::LINE;
        n->fk[0] = fa;
        n->fb[0] = fb;
        // std::cout << n->fk[0] << " " << n->fb[0] << "\n";

        if(errs < 8){
            n->model_type = modelType::LINE;
            n->fk[0] = fa;
            n->fb[0] = fb;
            node_type_counts[0]++;
        }
        // else if(errs < 16){
        //     if(k > k0 && k < k3){
        //         // 
        //         n->model_type = modelType::LINE;
        //         n->fk[0] = fa;
        //         n->fb[0] = fb - 0.8*errs;

        //     }else if(k < k0 && k > k3){
        //         // 
        //         n->model_type = modelType::LINE;
        //         n->fk[0] = fa;
        //         n->fb[0] = fb + 0.8*errs;
        //     }else{
        //         n->model_type = modelType::LINE;
        //         n->fk[0] = fa;
        //         n->fb[0] = fb;
        //     }
        // }

        // else{
        //     n->model_type = modelType::LINE;
        //     n->fk[0] = fa;
        //     n->fb[0] = fb;

        // }

        else{
            std::vector<std::vector<double>> dp(ele_num,std::vector<double>(ele_num,0));
            // dp
            for(int i=0;i<ele_num;i++){
                for(int j=i;j<ele_num;j++){
                    dp[i][j] = meaning_distance(ka, kb, keys, sites, i, j);
                }
            }
            // int keys_size = keys.size();
            // for(int i=0;i<keys_size;i++){
            //     std::cout << keys[i] << " ";
            // }
            // std::cout << "\n";
            double min = DBL_MAX;
            int sp_site[4] = {0};
            for(int i=1;i<ele_num-2;i++){
                for(int j=i+1;j<ele_num-1;j++){
                    double sum = dp[0][i] + dp[i][j] + dp[j][ele_num-1];
                    if(sum < min){
                        sp_site[0] = 0;
                        sp_site[1] = i;
                        sp_site[2] = j;
                        sp_site[3] = ele_num-1;
                        min = sum;
                    }
                    // std::cout << sum << "\n";
                }
            }
            
            // std::cout << "sum=" << min << "\n";
            // std::cout << "===\n" ;

            // for(auto e : sp_site){
            //     std::cout << sites[e] <<  " "; 
            // }
            // std::cout << "\n";

            // cout_nodeinfo(n);
            double final_k[3] = {0};
            double final_b[3] = {0};
            for(int i=0;i<3;i++){
                final_k[i] = (sites[sp_site[i+1]] - sites[sp_site[i]]) / (keys[sp_site[i+1]] - keys[sp_site[i]])  ;
                // std::cout << keys[sp_site[i+1]] << "\n";
                final_b[i] = sites[sp_site[i]] - final_k[i] * keys[sp_site[i]];

            }
            // std::cout << final_k[0] << " " << final_k[1] << " " << final_k[2] << "\n";

            if(k > final_k[0] && k < final_k[2]){
                // 
                if(final_k[2]<final_k[1] && final_k[1]<final_k[0]){
                    n->model_type = modelType::TU;
                }else{
                    n->model_type = modelType::SX;
                }
                
            }else if(k < final_k[0] && k > final_k[2]){
                // 
                if(final_k[2]>final_k[1] && final_k[1]>final_k[0]){
                    n->model_type = modelType::AO;
                }else{
                    n->model_type = modelType::SX;
                }
                
            }else{
                // small S
                n->model_type = modelType::SX;
            }
            // std::cout << final_k[0] << " " << final_k[1] << " " << final_k[2] << "\n";
            memcpy(n->fk,final_k,sizeof(final_k));
            memcpy(n->fb,final_b,sizeof(final_b));
            // std::cout << n->fk[0] << " " << n->fk[1] << " " << n->fk[2] << "\n";
        }

        n->insert_count = 0;
        n->delete_count = 0;
        return true;
    }



    /// Searches for the first key in the node n greater than key. Uses binary
    /// search with an optional linear self-verification. This is a template
    /// function, because the slotkey array is located at different places in
    /// leaf_node and inner_node.
    template <typename node_type>
    inline int find_upper(const node_type* n, const key_type& key) const
    {
        if (0 && sizeof(n->slotkey) > traits::binsearch_threshold)
        {
            if (n->slotuse == 0) return 0;

            int lo = 0, hi = n->slotuse;

            while (lo < hi)
            {
                int mid = (lo + hi) >> 1;

                if (key_less(key, n->slotkey[mid])) {
                    hi = mid;     // key < mid
                }
                else {
                    lo = mid + 1; // key >= mid
                }
            }

            BTREE_PRINT("btree::find_upper: on " << n << " key " << key << " -> " << lo << " / " << hi);

            // verify result using simple linear search
            if (selfverify)
            {
                int i = 0;
                while (i < n->slotuse && key_lessequal(n->slotkey[i], key)) ++i;

                BTREE_PRINT("btree::find_upper testfind: " << i);
                BTREE_ASSERT(i == hi);
            }

            return lo;
        }
        else // for nodes <= binsearch_threshold do linear search.
        {
            int lo = 0;
            while (lo < n->slotuse && key_lessequal(n->slotkey[lo], key)) ++lo;
            return lo;
        }
    }

public:
    // *** Access Functions to the Item Count

    /// Return the number of key/data pairs in the B+ tree
    inline size_type size() const
    {
        return m_stats.itemcount;
    }

    /// Returns true if there is at least one key/data pair in the B+ tree
    inline bool empty() const
    {
        return (size() == size_type(0));
    }

    /// Returns the largest possible size of the B+ Tree. This is just a
    /// function required by the STL standard, the B+ Tree can hold more items.
    inline size_type max_size() const
    {
        return size_type(-1);
    }

    /// Return a const reference to the current statistics.
    inline const struct tree_stats & get_stats() const
    {
        return m_stats;
    }

public:
    // *** Standard Access Functions Querying the Tree by Descending to a Leaf

    /// Non-STL function checking whether a key is in the B+ tree. The same as
    /// (find(k) != end()) or (count() != 0).
    bool exists(const key_type& key) const
    {
        const node* n = m_root;
        if (!n) return false;

        while (!n->isleafnode())
        {
            const inner_node* inner = static_cast<const inner_node*>(n);
            int slot = find_lower(inner, key);

            n = inner->childid[slot];
        }

        const leaf_node* leaf = static_cast<const leaf_node*>(n);

        int slot = find_lower(leaf, key);
        return (slot < leaf->slotuse && key_equal(key, leaf->slotkey[slot]));
    }

    /// Tries to locate a key in the B+ tree and returns an iterator to the
    /// key/data slot if found. If unsuccessful it returns end().
    iterator find(const key_type& key)
    {
        node* n = m_root;
        if (!n) return end();
        btree_level=0;
        while (!n->isleafnode())
        {
            const inner_node* inner = static_cast<const inner_node*>(n);
            int slot = find_lower(inner, key);
            n = inner->childid[slot];
            btree_level++;
        }
        leaf_node* leaf = static_cast<leaf_node*>(n);
        int slot = find_lower(leaf, key);
        return (slot < leaf->slotuse && key_equal(key, leaf->slotkey[slot])) ? iterator(leaf, slot) : end();
    }

    

    size_t* find_x(const key_type& key)
    {
        btree_level = 0;
        node* n = m_root;
        const inner_node* r = static_cast<const inner_node*>(n);
        if (!n) return nullptr;

        while (!n->isleafnode())
        {
            const inner_node* inner = static_cast<const inner_node*>(n);
            int slot = find_lower_liner_x(inner, key);

            n = inner->childid[slot];
            btree_level++;
        }
        leaf_node* leaf = static_cast<leaf_node*>(n);
        int slot = find_lower_liner_x(leaf, key);

        return (slot < leaf->slotuse && key_equal(key, leaf->slotkey[slot]))
               ? &(leaf->slotdata[slot]) : nullptr;
    }

    /// Tries to locate a key in the B+ tree and returns an constant iterator
    /// to the key/data slot if found. If unsuccessful it returns end().
    const_iterator find(const key_type& key) const
    {
        const node* n = m_root;
        if (!n) return end();
        while (!n->isleafnode())
        {
            const inner_node* inner = static_cast<const inner_node*>(n);
            int slot = find_lower(inner, key);

            n = inner->childid[slot];
        }

        const leaf_node* leaf = static_cast<const leaf_node*>(n);

        int slot = find_lower(leaf, key);
        return (slot < leaf->slotuse && key_equal(key, leaf->slotkey[slot]))
               ? const_iterator(leaf, slot) : end();
    }

    /// Tries to locate a key in the B+ tree and returns the number of
    /// identical key entries found.
    size_type count(const key_type& key) const
    {
        const node* n = m_root;
        if (!n) return 0;

        while (!n->isleafnode())
        {
            const inner_node* inner = static_cast<const inner_node*>(n);
            int slot = find_lower(inner, key);

            n = inner->childid[slot];
        }

        const leaf_node* leaf = static_cast<const leaf_node*>(n);

        int slot = find_lower(leaf, key);
        size_type num = 0;

        while (leaf && slot < leaf->slotuse && key_equal(key, leaf->slotkey[slot]))
        {
            ++num;
            if (++slot >= leaf->slotuse)
            {
                leaf = leaf->nextleaf;
                slot = 0;
            }
        }

        return num;
    }

    /// Searches the B+ tree and returns an iterator to the first pair
    /// equal to or greater than key, or end() if all keys are smaller.
    iterator lower_bound(const key_type& key)
    {
        node* n = m_root;
        if (!n) return end();

        while (!n->isleafnode())
        {
            const inner_node* inner = static_cast<const inner_node*>(n);
            int slot = find_lower(inner, key);

            n = inner->childid[slot];
        }

        leaf_node* leaf = static_cast<leaf_node*>(n);

        int slot = find_lower(leaf, key);
        return iterator(leaf, slot);
    }

    /// Searches the B+ tree and returns a constant iterator to the
    /// first pair equal to or greater than key, or end() if all keys
    /// are smaller.
    const_iterator lower_bound(const key_type& key) const
    {
        const node* n = m_root;
        if (!n) return end();

        while (!n->isleafnode())
        {
            const inner_node* inner = static_cast<const inner_node*>(n);
            int slot = find_lower(inner, key);

            n = inner->childid[slot];
        }

        const leaf_node* leaf = static_cast<const leaf_node*>(n);

        int slot = find_lower(leaf, key);
        return const_iterator(leaf, slot);
    }

    /// Searches the B+ tree and returns an iterator to the first pair
    /// greater than key, or end() if all keys are smaller or equal.
    iterator upper_bound(const key_type& key)
    {
        node* n = m_root;
        if (!n) return end();

        while (!n->isleafnode())
        {
            const inner_node* inner = static_cast<const inner_node*>(n);
            int slot = find_upper(inner, key);

            n = inner->childid[slot];
        }

        leaf_node* leaf = static_cast<leaf_node*>(n);

        int slot = find_upper(leaf, key);
        return iterator(leaf, slot);
    }

    /// Searches the B+ tree and returns a constant iterator to the
    /// first pair greater than key, or end() if all keys are smaller
    /// or equal.
    const_iterator upper_bound(const key_type& key) const
    {
        const node* n = m_root;
        if (!n) return end();

        while (!n->isleafnode())
        {
            const inner_node* inner = static_cast<const inner_node*>(n);
            int slot = find_upper(inner, key);

            n = inner->childid[slot];
        }

        const leaf_node* leaf = static_cast<const leaf_node*>(n);

        int slot = find_upper(leaf, key);
        return const_iterator(leaf, slot);
    }

    /// Searches the B+ tree and returns both lower_bound() and upper_bound().
    inline std::pair<iterator, iterator> equal_range(const key_type& key)
    {
        return std::pair<iterator, iterator>(lower_bound(key), upper_bound(key));
    }

    /// Searches the B+ tree and returns both lower_bound() and upper_bound().
    inline std::pair<const_iterator, const_iterator> equal_range(const key_type& key) const
    {
        return std::pair<const_iterator, const_iterator>(lower_bound(key), upper_bound(key));
    }

public:
    // *** B+ Tree Object Comparison Functions

    /// Equality relation of B+ trees of the same type. B+ trees of the same
    /// size and equal elements (both key and data) are considered
    /// equal. Beware of the random ordering of duplicate keys.
    inline bool operator == (const self_type& other) const
    {
        return (size() == other.size()) && std::equal(begin(), end(), other.begin());
    }

    /// Inequality relation. Based on operator==.
    inline bool operator != (const self_type& other) const
    {
        return !(*this == other);
    }

    /// Total ordering relation of B+ trees of the same type. It uses
    /// std::lexicographical_compare() for the actual comparison of elements.
    inline bool operator < (const self_type& other) const
    {
        return std::lexicographical_compare(begin(), end(), other.begin(), other.end());
    }

    /// Greater relation. Based on operator<.
    inline bool operator > (const self_type& other) const
    {
        return other < *this;
    }

    /// Less-equal relation. Based on operator<.
    inline bool operator <= (const self_type& other) const
    {
        return !(other < *this);
    }

    /// Greater-equal relation. Based on operator<.
    inline bool operator >= (const self_type& other) const
    {
        return !(*this < other);
    }

public:
    /// *** Fast Copy: Assign Operator and Copy Constructors

    /// Assignment operator. All the key/data pairs are copied
    inline self_type& operator = (const self_type& other)
    {
        if (this != &other)
        {
            clear();

            m_key_less = other.key_comp();
            m_allocator = other.get_allocator();

            if (other.size() != 0)
            {
                m_stats.leaves = m_stats.innernodes = 0;
                if (other.m_root) {
                    m_root = copy_recursive(other.m_root);
                }
                m_stats = other.m_stats;
            }

            if (selfverify) verify();
        }
        return *this;
    }

    /// Copy constructor. The newly initialized B+ tree object will contain a
    /// copy of all key/data pairs.
    inline btree(const btree& other)
        : m_root(NULL), m_headleaf(NULL), m_tailleaf(NULL),
          m_stats(other.m_stats),
          m_key_less(other.key_comp()),
          m_allocator(other.get_allocator())
    {
        if (size() > 0)
        {
            m_stats.leaves = m_stats.innernodes = 0;
            if (other.m_root) {
                m_root = copy_recursive(other.m_root);
            }
            if (selfverify) verify();
        }
    }

private:
    /// Recursively copy nodes from another B+ tree object
    struct node * copy_recursive(const node* n)
    {
        if (n->isleafnode())
        {
            const leaf_node* leaf = static_cast<const leaf_node*>(n);
            leaf_node* newleaf = allocate_leaf();

            newleaf->slotuse = leaf->slotuse;
            std::copy(leaf->slotkey, leaf->slotkey + leaf->slotuse, newleaf->slotkey);
            data_copy(leaf->slotdata, leaf->slotdata + leaf->slotuse, newleaf->slotdata);

            if (m_headleaf == NULL)
            {
                m_headleaf = m_tailleaf = newleaf;
                newleaf->prevleaf = newleaf->nextleaf = NULL;
            }
            else
            {
                newleaf->prevleaf = m_tailleaf;
                m_tailleaf->nextleaf = newleaf;
                m_tailleaf = newleaf;
            }

            return newleaf;
        }
        else
        {
            const inner_node* inner = static_cast<const inner_node*>(n);
            inner_node* newinner = allocate_inner(inner->level);

            newinner->slotuse = inner->slotuse;
            std::copy(inner->slotkey, inner->slotkey + inner->slotuse, newinner->slotkey);

            for (unsigned short slot = 0; slot <= inner->slotuse; ++slot)
            {
                newinner->childid[slot] = copy_recursive(inner->childid[slot]);
            }

            return newinner;
        }
    }

public:
    // *** Public Insertion Functions

    /// Attempt to insert a key/data pair into the B+ tree. If the tree does not
    /// allow duplicate keys, then the insert may fail if it is already
    /// present.
    inline std::pair<iterator, bool> insert(const pair_type& x)
    {
        return insert_start(x.first, x.second);
    }

    /// Attempt to insert a key/data pair into the B+ tree. Beware that if
    /// key_type == data_type, then the template iterator insert() is called
    /// instead. If the tree does not allow duplicate keys, then the insert may
    /// fail if it is already present.
    inline std::pair<iterator, bool> insert(const key_type& key, const data_type& data)
    {
        return insert_start(key, data);
    }

    inline std::pair<iterator, bool> insert_x(const key_type& key, const data_type& data)
    {
        return insert_start_x(key, data);
    }

    inline std::pair<iterator, bool> insert_l(const key_type& key, const data_type& data)
    {
        return insert_start_l(key, data);
    }

    /// Attempt to insert a key/data pair into the B+ tree. This function is the
    /// same as the other insert, however if key_type == data_type then the
    /// non-template function cannot be called. If the tree does not allow
    /// duplicate keys, then the insert may fail if it is already present.
    inline std::pair<iterator, bool> insert2(const key_type& key, const data_type& data)
    {
        return insert_start(key, data);
    }

    /// Attempt to insert a key/data pair into the B+ tree. The iterator hint
    /// is currently ignored by the B+ tree insertion routine.
    inline iterator insert(iterator /* hint */, const pair_type& x)
    {
        return insert_start(x.first, x.second).first;
    }

    /// Attempt to insert a key/data pair into the B+ tree. The iterator hint is
    /// currently ignored by the B+ tree insertion routine.
    inline iterator insert2(iterator /* hint */, const key_type& key, const data_type& data)
    {
        return insert_start(key, data).first;
    }

    /// Attempt to insert the range [first,last) of value_type pairs into the
    /// B+ tree. Each key/data pair is inserted individually; to bulk load the
    /// tree, use a constructor with range.
    template <typename InputIterator>
    inline void insert(InputIterator first, InputIterator last)
    {
        InputIterator iter = first;
        while (iter != last)
        {
            insert(*iter);
            ++iter;
        }
    }

private:
    // *** Private Insertion Functions

    /// Start the insertion descent at the current root and handle root
    /// splits. Returns true if the item was inserted
    std::pair<iterator, bool> insert_start(const key_type& key, const data_type& value)
    {
        node* newchild = NULL;
        key_type newkey = key_type();

        if (m_root == NULL) {
            m_root = m_headleaf = m_tailleaf = allocate_leaf();
        }

        std::pair<iterator, bool> r = insert_descend(m_root, key, value, &newkey, &newchild);

        if (newchild)
        {
            inner_node* newroot = allocate_inner(m_root->level + 1);
            newroot->slotkey[0] = newkey;

            newroot->childid[0] = m_root;
            newroot->childid[1] = newchild;

            newroot->slotuse = 1;

            m_root = newroot;
        }

        // increment itemcount if the item was inserted
        if (r.second) ++m_stats.itemcount;

#ifdef BTREE_DEBUG
        if (debug) print(std::cout);
#endif

        if (selfverify) {
            verify();
            BTREE_ASSERT(exists(key));
        }

        return r;
    }

    std::pair<iterator, bool> insert_start_x(const key_type& key, const data_type& value)
    {
        node* newchild = NULL;
        key_type newkey = key_type();

        if (m_root == NULL) {
            m_root = m_headleaf = m_tailleaf = allocate_leaf();
        }

        std::pair<iterator, bool> r = insert_descend_x(m_root, key, value, &newkey, &newchild);

        if (newchild)
        {
            inner_node* newroot = allocate_inner(m_root->level + 1);
            newroot->slotkey[0] = newkey;

            newroot->childid[0] = m_root;
            newroot->childid[1] = newchild;

            newroot->slotuse = 1;

            m_root = newroot;
        }

        // increment itemcount if the item was inserted
        if (r.second) ++m_stats.itemcount;

#ifdef BTREE_DEBUG
        if (debug) print(std::cout);
#endif

        if (selfverify) {
            verify();
            BTREE_ASSERT(exists(key));
        }

        return r;
    }

    std::pair<iterator, bool> insert_start_l(const key_type& key, const data_type& value)
    {
        node* newchild = NULL;
        key_type newkey = key_type();

        if (m_root == NULL) {
            m_root = m_headleaf = m_tailleaf = allocate_leaf();
        }

        std::pair<iterator, bool> r = insert_descend_l(m_root, key, value, &newkey, &newchild);

        if (newchild)
        {
            inner_node* newroot = allocate_inner(m_root->level + 1);
            newroot->slotkey[0] = newkey;

            newroot->childid[0] = m_root;
            newroot->childid[1] = newchild;

            newroot->slotuse = 1;

            m_root = newroot;
        }

        // increment itemcount if the item was inserted
        if (r.second) ++m_stats.itemcount;

#ifdef BTREE_DEBUG
        if (debug) print(std::cout);
#endif

        if (selfverify) {
            verify();
            BTREE_ASSERT(exists(key));
        }

        return r;
    }


    /**
     * @brief Insert an item into the B+ tree.
     *
     * Descend down the nodes to a leaf, insert the key/data pair in a free
     * slot. If the node overflows, then it must be split and the new split
     * node inserted into the parent. Unroll / this splitting up to the root.
    */
    std::pair<iterator, bool> insert_descend(node* n,
                                             const key_type& key, const data_type& value,
                                             key_type* splitkey, node** splitnode)
    {
        if (!n->isleafnode())
        {
            inner_node* inner = static_cast<inner_node*>(n);

            key_type newkey = key_type();
            node* newchild = NULL;

            int slot = find_lower(inner, key);

            BTREE_PRINT("btree::insert_descend into " << inner->childid[slot]);

            std::pair<iterator, bool> r = insert_descend(inner->childid[slot],
                                                         key, value, &newkey, &newchild);

            if (newchild)
            {
                BTREE_PRINT("btree::insert_descend newchild with key " << newkey << " node " << newchild << " at slot " << slot);

                if (inner->isfull())
                {
                    // key
                    split_inner_node(inner, splitkey, splitnode, slot);

                    BTREE_PRINT("btree::insert_descend done split_inner: putslot: " << slot << " putkey: " << newkey << " upkey: " << *splitkey);

#ifdef BTREE_DEBUG
                    if (debug)
                    {
                        print_node(std::cout, inner);
                        print_node(std::cout, *splitnode);
                    }
#endif

                    // check if insert slot is in the split sibling node
                    BTREE_PRINT("btree::insert_descend switch: " << slot << " > " << inner->slotuse + 1);

                    if (slot == inner->slotuse + 1 && inner->slotuse < (*splitnode)->slotuse)
                    {
                        // special case when the insert slot matches the split
                        // place between the two nodes, then the insert key
                        // becomes the split key.

                        BTREE_ASSERT(inner->slotuse + 1 < innerslotmax);

                        inner_node* splitinner = static_cast<inner_node*>(*splitnode);

                        // move the split key and it's datum into the left node
                        inner->slotkey[inner->slotuse] = *splitkey;
                        inner->childid[inner->slotuse + 1] = splitinner->childid[0];
                        inner->slotuse++;

                        // set new split key and move corresponding datum into right node
                        splitinner->childid[0] = newchild;
                        *splitkey = newkey;

                        return r;
                    }
                    else if (slot >= inner->slotuse + 1)
                    {
                        // in case the insert slot is in the newly create split
                        // node, we reuse the code below.

                        slot -= inner->slotuse + 1;
                        inner = static_cast<inner_node*>(*splitnode);
                        BTREE_PRINT("btree::insert_descend switching to splitted node " << inner << " slot " << slot);
                    }
                }

                // move items and put pointer to child node into correct slot
                BTREE_ASSERT(slot >= 0 && slot <= inner->slotuse);

                std::copy_backward(inner->slotkey + slot, inner->slotkey + inner->slotuse,
                                   inner->slotkey + inner->slotuse + 1);
                std::copy_backward(inner->childid + slot, inner->childid + inner->slotuse + 1,
                                   inner->childid + inner->slotuse + 2);
                // key
                inner->slotkey[slot] = newkey;
                inner->childid[slot + 1] = newchild;
                inner->slotuse++;
            }

            return r;
        }
        else // n->isleafnode() == true
        {
            leaf_node* leaf = static_cast<leaf_node*>(n);

            int slot = find_lower(leaf, key);

            if (!allow_duplicates && slot < leaf->slotuse && key_equal(key, leaf->slotkey[slot])) {
                return std::pair<iterator, bool>(iterator(leaf, slot), false);
            }

            if (leaf->isfull())
            {
                split_leaf_node(leaf, splitkey, splitnode);

                // check if insert slot is in the split sibling node
                if (slot >= leaf->slotuse)
                {
                    slot -= leaf->slotuse;
                    leaf = static_cast<leaf_node*>(*splitnode);
                }
            }

            // move items and put data item into correct data slot
            BTREE_ASSERT(slot >= 0 && slot <= leaf->slotuse);

            std::copy_backward(leaf->slotkey + slot, leaf->slotkey + leaf->slotuse,
                               leaf->slotkey + leaf->slotuse + 1);
            data_copy_backward(leaf->slotdata + slot, leaf->slotdata + leaf->slotuse,
                               leaf->slotdata + leaf->slotuse + 1);

            leaf->slotkey[slot] = key;
            if (!used_as_set) leaf->slotdata[slot] = value;
            leaf->slotuse++;

            if (splitnode && leaf != *splitnode && slot == leaf->slotuse - 1)
            {
                // special case: the node was split, and the insert is at the
                // last slot of the old node. then the splitkey must be
                // updated.
                *splitkey = key;
            }

            return std::pair<iterator, bool>(iterator(leaf, slot), true);
        }
    }



    // insert x
    std::pair<iterator, bool> insert_descend_x(node* n,
                                             const key_type& key, const data_type& value,
                                             key_type* splitkey, node** splitnode)
    {
        if (!n->isleafnode())
        {
            inner_node* inner = static_cast<inner_node*>(n);

            key_type newkey = key_type();
            node* newchild = NULL;

            int slot = find_lower_x(inner, key);

            BTREE_PRINT("btree::insert_descend into " << inner->childid[slot]);

            std::pair<iterator, bool> r = insert_descend_x(inner->childid[slot],
                                                         key, value, &newkey, &newchild);

            if (newchild)
            {
                BTREE_PRINT("btree::insert_descend newchild with key " << newkey << " node " << newchild << " at slot " << slot);

                if (inner->isfull())
                {
                    // key
                    split_inner_node(inner, splitkey, splitnode, slot);
                    generate_func_model(inner);
                    generate_func_model(static_cast<inner_node*>(*splitnode));

                    BTREE_PRINT("btree::insert_descend done split_inner: putslot: " << slot << " putkey: " << newkey << " upkey: " << *splitkey);

#ifdef BTREE_DEBUG
                    if (debug)
                    {
                        print_node(std::cout, inner);
                        print_node(std::cout, *splitnode);
                    }
#endif

                    // check if insert slot is in the split sibling node
                    BTREE_PRINT("btree::insert_descend switch: " << slot << " > " << inner->slotuse + 1);

                    if (slot == inner->slotuse + 1 && inner->slotuse < (*splitnode)->slotuse)
                    {
                        // special case when the insert slot matches the split
                        // place between the two nodes, then the insert key
                        // becomes the split key.

                        BTREE_ASSERT(inner->slotuse + 1 < innerslotmax);

                        inner_node* splitinner = static_cast<inner_node*>(*splitnode);

                        // move the split key and it's datum into the left node
                        inner->slotkey[inner->slotuse] = *splitkey;
                        inner->childid[inner->slotuse + 1] = splitinner->childid[0];
                        inner->slotuse++;

                        // set new split key and move corresponding datum into right node
                        splitinner->childid[0] = newchild;
                        *splitkey = newkey;

                        return r;
                    }
                    else if (slot >= inner->slotuse + 1)
                    {
                        // in case the insert slot is in the newly create split
                        // node, we reuse the code below.

                        slot -= inner->slotuse + 1;
                        inner = static_cast<inner_node*>(*splitnode);
                        BTREE_PRINT("btree::insert_descend switching to splitted node " << inner << " slot " << slot);
                    }
                }




                // move items and put pointer to child node into correct slot
                BTREE_ASSERT(slot >= 0 && slot <= inner->slotuse);

                std::copy_backward(inner->slotkey + slot, inner->slotkey + inner->slotuse,
                                   inner->slotkey + inner->slotuse + 1);
                std::copy_backward(inner->childid + slot, inner->childid + inner->slotuse + 1,
                                   inner->childid + inner->slotuse + 2);
                // key
                inner->slotkey[slot] = newkey;
                inner->childid[slot + 1] = newchild;
                inner->slotuse++;
            }

            if(inner->insert_count > 2 || inner->delete_count > 2){
                generate_func_model(inner);
            }
            inner->insert_count++;


            return r;
        }
        else // n->isleafnode() == true
        {
            leaf_node* leaf = static_cast<leaf_node*>(n);

            int slot = find_lower_x(leaf, key);

            if (!allow_duplicates && slot < leaf->slotuse && key_equal(key, leaf->slotkey[slot])) {
                return std::pair<iterator, bool>(iterator(leaf, slot), false);
            }

            if (leaf->isfull())
            {
                split_leaf_node(leaf, splitkey, splitnode);
                generate_func_model(leaf);
                generate_func_model(static_cast<leaf_node*>(*splitnode));

                // check if insert slot is in the split sibling node
                if (slot >= leaf->slotuse)
                {
                    slot -= leaf->slotuse;
                    leaf = static_cast<leaf_node*>(*splitnode);
                }
            }
            if(leaf->insert_count > 2 || leaf->delete_count > 2){
                generate_func_model(leaf);
            }
            leaf->insert_count++;


            // move items and put data item into correct data slot
            BTREE_ASSERT(slot >= 0 && slot <= leaf->slotuse);

            std::copy_backward(leaf->slotkey + slot, leaf->slotkey + leaf->slotuse,
                               leaf->slotkey + leaf->slotuse + 1);
            data_copy_backward(leaf->slotdata + slot, leaf->slotdata + leaf->slotuse,
                               leaf->slotdata + leaf->slotuse + 1);

            leaf->slotkey[slot] = key;
            if (!used_as_set) leaf->slotdata[slot] = value;
            leaf->slotuse++;

            if (splitnode && leaf != *splitnode && slot == leaf->slotuse - 1)
            {
                // special case: the node was split, and the insert is at the
                // last slot of the old node. then the splitkey must be
                // updated.
                *splitkey = key;
            }

            return std::pair<iterator, bool>(iterator(leaf, slot), true);
        }
    }


    /// Split up a leaf node into two equally-filled sibling leaves. Returns
    /// the new nodes and it's insertion key in the two parameters.
    void split_leaf_node(leaf_node* leaf, key_type* _newkey, node** _newleaf)
    {
        BTREE_ASSERT(leaf->isfull());

        unsigned int mid = (leaf->slotuse >> 1);

        BTREE_PRINT("btree::split_leaf_node on " << leaf);

        leaf_node* newleaf = allocate_leaf();

        newleaf->slotuse = leaf->slotuse - mid;

        newleaf->nextleaf = leaf->nextleaf;
        if (newleaf->nextleaf == NULL) {
            BTREE_ASSERT(leaf == m_tailleaf);
            m_tailleaf = newleaf;
        }
        else {
            newleaf->nextleaf->prevleaf = newleaf;
        }

        std::copy(leaf->slotkey + mid, leaf->slotkey + leaf->slotuse,
                  newleaf->slotkey);
        data_copy(leaf->slotdata + mid, leaf->slotdata + leaf->slotuse,
                  newleaf->slotdata);

        leaf->slotuse = mid;
        leaf->nextleaf = newleaf;
        newleaf->prevleaf = leaf;

        *_newkey = leaf->slotkey[leaf->slotuse - 1];
        *_newleaf = newleaf;
    }

    /// Split up an inner node into two equally-filled sibling nodes. Returns
    /// the new nodes and it's insertion key in the two parameters. Requires
    /// the slot of the item will be inserted, so the nodes will be the same
    /// size after the insert.
    void split_inner_node(inner_node* inner, key_type* _newkey, node** _newinner, unsigned int addslot)
    {
        BTREE_ASSERT(inner->isfull());

        unsigned int mid = (inner->slotuse >> 1);

        BTREE_PRINT("btree::split_inner: mid " << mid << " addslot " << addslot);

        // if the split is uneven and the overflowing item will be put into the
        // larger node, then the smaller split node may underflow
        if (addslot <= mid && mid > inner->slotuse - (mid + 1))
            mid--;

        BTREE_PRINT("btree::split_inner: mid " << mid << " addslot " << addslot);

        BTREE_PRINT("btree::split_inner_node on " << inner << " into two nodes " << mid << " and " << inner->slotuse - (mid + 1) << " sized");

        inner_node* newinner = allocate_inner(inner->level);

        newinner->slotuse = inner->slotuse - (mid + 1);

        std::copy(inner->slotkey + mid + 1, inner->slotkey + inner->slotuse,
                  newinner->slotkey);
        std::copy(inner->childid + mid + 1, inner->childid + inner->slotuse + 1,
                  newinner->childid);
        // mid+1slotusemid
        inner->slotuse = mid;

        *_newkey = inner->slotkey[mid];
        *_newinner = newinner;
    }

public:
    // *** Bulk Loader - Construct Tree from Sorted Sequence

    /// Bulk load a sorted range. Loads items into leaves and constructs a
    /// B-tree above them. The tree must be empty when calling this function.
    template <typename Iterator>
    void bulk_load(Iterator ibegin, Iterator iend)
    {
        BTREE_ASSERT(empty());

        m_stats.itemcount = iend - ibegin;

        // calculate number of leaves needed, round up.
        size_t num_items = iend - ibegin;
        size_t num_leaves = (num_items + leafslotmax - 1) / leafslotmax;

        BTREE_PRINT("btree::bulk_load, level 0: " << m_stats.itemcount << " items into " << num_leaves << " leaves with up to " << ((iend - ibegin + num_leaves - 1) / num_leaves) << " items per leaf.");

        Iterator it = ibegin;
        for (size_t i = 0; i < num_leaves; ++i)
        {
            // allocate new leaf node
            leaf_node* leaf = allocate_leaf();

            // copy keys or (key,value) pairs into leaf nodes, uses template
            // switch leaf->set_slot().
            leaf->slotuse = static_cast<int>(num_items / (num_leaves - i));
            for (size_t s = 0; s < leaf->slotuse; ++s, ++it)
                leaf->set_slot(s, *it);

            if (m_tailleaf != NULL) {
                m_tailleaf->nextleaf = leaf;
                leaf->prevleaf = m_tailleaf;
            }
            else {
                m_headleaf = leaf;
            }
            m_tailleaf = leaf;

            num_items -= leaf->slotuse;
        }

        BTREE_ASSERT(it == iend && num_items == 0);

        // if the btree is so small to fit into one leaf, then we're done.
        if (m_headleaf == m_tailleaf) {
            m_root = m_headleaf;
            return;
        }

        BTREE_ASSERT(m_stats.leaves == num_leaves);

        // create first level of inner nodes, pointing to the leaves.
        size_t num_parents = (num_leaves + (innerslotmax + 1) - 1) / (innerslotmax + 1);

        BTREE_PRINT("btree::bulk_load, level 1: " << num_leaves << " leaves in " << num_parents << " inner nodes with up to " << ((num_leaves + num_parents - 1) / num_parents) << " leaves per inner node.");

        // save inner nodes and maxkey for next level.
        typedef std::pair<inner_node*, const key_type*> nextlevel_type;
        nextlevel_type* nextlevel = new nextlevel_type[num_parents];

        leaf_node* leaf = m_headleaf;
        for (size_t i = 0; i < num_parents; ++i)
        {
            // allocate new inner node at level 1
            inner_node* n = allocate_inner(1);

            n->slotuse = static_cast<int>(num_leaves / (num_parents - i));
            BTREE_ASSERT(n->slotuse > 0);
            --n->slotuse; // this counts keys, but an inner node has keys+1 children.

            // copy last key from each leaf and set child
            for (unsigned short s = 0; s < n->slotuse; ++s)
            {
                n->slotkey[s] = leaf->slotkey[leaf->slotuse - 1];
                n->childid[s] = leaf;
                leaf = leaf->nextleaf;
            }
            n->childid[n->slotuse] = leaf;

            // track max key of any descendant.
            nextlevel[i].first = n;
            nextlevel[i].second = &leaf->slotkey[leaf->slotuse - 1];

            leaf = leaf->nextleaf;
            num_leaves -= n->slotuse + 1;
        }

        BTREE_ASSERT(leaf == NULL && num_leaves == 0);

        // recursively build inner nodes pointing to inner nodes.
        for (int level = 2; num_parents != 1; ++level)
        {
            size_t num_children = num_parents;
            num_parents = (num_children + (innerslotmax + 1) - 1) / (innerslotmax + 1);

            BTREE_PRINT("btree::bulk_load, level " << level << ": " << num_children << " children in " << num_parents << " inner nodes with up to " << ((num_children + num_parents - 1) / num_parents) << " children per inner node.");

            size_t inner_index = 0;
            for (size_t i = 0; i < num_parents; ++i)
            {
                // allocate new inner node at level
                inner_node* n = allocate_inner(level);

                n->slotuse = static_cast<int>(num_children / (num_parents - i));
                BTREE_ASSERT(n->slotuse > 0);
                --n->slotuse; // this counts keys, but an inner node has keys+1 children.

                // copy children and maxkeys from nextlevel
                for (unsigned short s = 0; s < n->slotuse; ++s)
                {
                    n->slotkey[s] = *nextlevel[inner_index].second;
                    n->childid[s] = nextlevel[inner_index].first;
                    ++inner_index;
                }
                n->childid[n->slotuse] = nextlevel[inner_index].first;

                // reuse nextlevel array for parents, because we can overwrite
                // slots we've already consumed.
                nextlevel[i].first = n;
                nextlevel[i].second = nextlevel[inner_index].second;

                ++inner_index;
                num_children -= n->slotuse + 1;
            }

            BTREE_ASSERT(num_children == 0);
        }

        m_root = nextlevel[0].first;
        delete[] nextlevel;

        if (selfverify) verify();
    }


    // bulk x
    template <typename Iterator>
    void bulk_load_x(Iterator ibegin, Iterator iend)
    {
        BTREE_ASSERT(empty());

        m_stats.itemcount = iend - ibegin;

        // calculate number of leaves needed, round up.
        size_t num_items = iend - ibegin;
        size_t num_leaves = (num_items + leafslotmax - 1) / leafslotmax;

        BTREE_PRINT("btree::bulk_load, level 0: " << m_stats.itemcount << " items into " << num_leaves << " leaves with up to " << ((iend - ibegin + num_leaves - 1) / num_leaves) << " items per leaf.");

        Iterator it = ibegin;
        for (size_t i = 0; i < num_leaves; ++i)
        {
            // allocate new leaf node
            leaf_node* leaf = allocate_leaf();

            // copy keys or (key,value) pairs into leaf nodes, uses template
            // switch leaf->set_slot().
            leaf->slotuse = static_cast<int>(num_items / (num_leaves - i));
            for (size_t s = 0; s < leaf->slotuse; ++s, ++it)
                leaf->set_slot(s, *it);

            if (m_tailleaf != NULL) {
                m_tailleaf->nextleaf = leaf;
                leaf->prevleaf = m_tailleaf;
            }
            else {
                m_headleaf = leaf;
            }
            m_tailleaf = leaf;

            num_items -= leaf->slotuse;
            generate_func_model(leaf);
        }

        BTREE_ASSERT(it == iend && num_items == 0);

        // if the btree is so small to fit into one leaf, then we're done.
        if (m_headleaf == m_tailleaf) {
            m_root = m_headleaf;
            return;
        }

        BTREE_ASSERT(m_stats.leaves == num_leaves);

        // create first level of inner nodes, pointing to the leaves.
        size_t num_parents = (num_leaves + (innerslotmax + 1) - 1) / (innerslotmax + 1);

        BTREE_PRINT("btree::bulk_load, level 1: " << num_leaves << " leaves in " << num_parents << " inner nodes with up to " << ((num_leaves + num_parents - 1) / num_parents) << " leaves per inner node.");

        // save inner nodes and maxkey for next level.
        typedef std::pair<inner_node*, const key_type*> nextlevel_type;
        nextlevel_type* nextlevel = new nextlevel_type[num_parents];

        leaf_node* leaf = m_headleaf;
        for (size_t i = 0; i < num_parents; ++i)
        {
            // allocate new inner node at level 1
            inner_node* n = allocate_inner(1);

            n->slotuse = static_cast<int>(num_leaves / (num_parents - i));
            BTREE_ASSERT(n->slotuse > 0);
            --n->slotuse; // this counts keys, but an inner node has keys+1 children.

            // copy last key from each leaf and set child
            for (unsigned short s = 0; s < n->slotuse; ++s)
            {
                n->slotkey[s] = leaf->slotkey[leaf->slotuse - 1];
                n->childid[s] = leaf;
                leaf = leaf->nextleaf;
            }
            n->childid[n->slotuse] = leaf;

            // track max key of any descendant.
            nextlevel[i].first = n;
            nextlevel[i].second = &leaf->slotkey[leaf->slotuse - 1];

            leaf = leaf->nextleaf;
            num_leaves -= n->slotuse + 1;
            generate_func_model(n);
        }

        BTREE_ASSERT(leaf == NULL && num_leaves == 0);

        // recursively build inner nodes pointing to inner nodes.
        for (int level = 2; num_parents != 1; ++level)
        {
            size_t num_children = num_parents;
            num_parents = (num_children + (innerslotmax + 1) - 1) / (innerslotmax + 1);

            BTREE_PRINT("btree::bulk_load, level " << level << ": " << num_children << " children in " << num_parents << " inner nodes with up to " << ((num_children + num_parents - 1) / num_parents) << " children per inner node.");

            size_t inner_index = 0;
            for (size_t i = 0; i < num_parents; ++i)
            {
                // allocate new inner node at level
                inner_node* n = allocate_inner(level);

                n->slotuse = static_cast<int>(num_children / (num_parents - i));
                BTREE_ASSERT(n->slotuse > 0);
                --n->slotuse; // this counts keys, but an inner node has keys+1 children.

                // copy children and maxkeys from nextlevel
                for (unsigned short s = 0; s < n->slotuse; ++s)
                {
                    n->slotkey[s] = *nextlevel[inner_index].second;
                    n->childid[s] = nextlevel[inner_index].first;
                    ++inner_index;
                }
                n->childid[n->slotuse] = nextlevel[inner_index].first;

                // reuse nextlevel array for parents, because we can overwrite
                // slots we've already consumed.
                nextlevel[i].first = n;
                nextlevel[i].second = nextlevel[inner_index].second;

                ++inner_index;
                num_children -= n->slotuse + 1;
                generate_func_model(n);
            }

            BTREE_ASSERT(num_children == 0);
        }

        m_root = nextlevel[0].first;
        delete[] nextlevel;

        if (selfverify) verify();
    }

private:
    // *** Support Class Encapsulating Deletion Results

    /// Result flags of recursive deletion.
    enum result_flags_t
    {
        /// Deletion successful and no fix-ups necessary.
        btree_ok = 0,

        /// Deletion not successful because key was not found.
        btree_not_found = 1,

        /// Deletion successful, the last key was updated so parent slotkeys
        /// need updates.
        btree_update_lastkey = 2,

        /// Deletion successful, children nodes were merged and the parent
        /// needs to remove the empty node.
        btree_fixmerge = 4
    };

    /// B+ tree recursive deletion has much information which is needs to be
    /// passed upward.
    struct result_t
    {
        /// Merged result flags
        result_flags_t flags;

        /// The key to be updated at the parent's slot
        key_type       lastkey;

        /// Constructor of a result with a specific flag, this can also be used
        /// as for implicit conversion.
        inline explicit result_t(result_flags_t f = btree_ok)
            : flags(f), lastkey()
        { }

        /// Constructor with a lastkey value.
        inline result_t(result_flags_t f, const key_type& k)
            : flags(f), lastkey(k)
        { }

        /// Test if this result object has a given flag set.
        inline bool    has(result_flags_t f) const
        {
            return (flags & f) != 0;
        }

        /// Merge two results OR-ing the result flags and overwriting lastkeys.
        inline result_t& operator |= (const result_t& other)
        {
            flags = result_flags_t(flags | other.flags);

            // we overwrite existing lastkeys on purpose
            if (other.has(btree_update_lastkey))
                lastkey = other.lastkey;

            return *this;
        }
    };

public:
    // *** Public Erase Functions

    /// Erases one (the first) of the key/data pairs associated with the given
    /// key.
    bool erase_one(const key_type& key)
    {
        BTREE_PRINT("btree::erase_one(" << key << ") on btree size " << size());

        if (selfverify) verify();

        if (!m_root) return false;

        result_t result = erase_one_descend(key, m_root, NULL, NULL, NULL, NULL, NULL, 0);

        if (!result.has(btree_not_found))
            --m_stats.itemcount;

#ifdef BTREE_DEBUG
        if (debug) print(std::cout);
#endif
        if (selfverify) verify();

        return !result.has(btree_not_found);
    }

    /// Erases all the key/data pairs associated with the given key. This is
    /// implemented using erase_one().
    size_type erase(const key_type& key)
    {
        size_type c = 0;

        while (erase_one(key))
        {
            ++c;
            if (!allow_duplicates) break;
        }

        return c;
    }

    /// Erase the key/data pair referenced by the iterator.
    void erase(iterator iter)
    {
        BTREE_PRINT("btree::erase_iter(" << iter.currnode << "," << iter.currslot << ") on btree size " << size());

        if (selfverify) verify();

        if (!m_root) return;

        result_t result = erase_iter_descend(iter, m_root, NULL, NULL, NULL, NULL, NULL, 0);

        if (!result.has(btree_not_found))
            --m_stats.itemcount;

#ifdef BTREE_DEBUG
        if (debug) print(std::cout);
#endif
        if (selfverify) verify();
    }

#ifdef BTREE_TODO
    /// Erase all key/data pairs in the range [first,last). This function is
    /// currently not implemented by the B+ Tree.
    void erase(iterator /* first */, iterator /* last */)
    {
        abort();
    }
#endif

private:
    // *** Private Erase Functions

    /** @brief Erase one (the first) key/data pair in the B+ tree matching key.
     *
     * Descends down the tree in search of key. During the descent the parent,
     * left and right siblings and their parents are computed and passed
     * down. Once the key/data pair is found, it is removed from the leaf. If
     * the leaf underflows 6 different cases are handled. These cases resolve
     * the underflow by shifting key/data pairs from adjacent sibling nodes,
     * merging two sibling nodes or trimming the tree.
     */
    result_t erase_one_descend(const key_type& key,
                               node* curr,
                               node* left, node* right,
                               inner_node* leftparent, inner_node* rightparent,
                               inner_node* parent, unsigned int parentslot)
    {
        if (curr->isleafnode())
        {
            leaf_node* leaf = static_cast<leaf_node*>(curr);
            leaf_node* leftleaf = static_cast<leaf_node*>(left);
            leaf_node* rightleaf = static_cast<leaf_node*>(right);

            int slot = find_lower(leaf, key);

            if (slot >= leaf->slotuse || !key_equal(key, leaf->slotkey[slot]))
            {
                BTREE_PRINT("Could not find key " << key << " to erase.");

                return result_t(btree_not_found);
            }

            BTREE_PRINT("Found key in leaf " << curr << " at slot " << slot);

            std::copy(leaf->slotkey + slot + 1, leaf->slotkey + leaf->slotuse,
                      leaf->slotkey + slot);
            data_copy(leaf->slotdata + slot + 1, leaf->slotdata + leaf->slotuse,
                      leaf->slotdata + slot);

            leaf->slotuse--;

            result_t myres = result_t(btree_ok);

            // if the last key of the leaf was changed, the parent is notified
            // and updates the key of this leaf
            if (slot == leaf->slotuse)
            {
                if (parent && parentslot < parent->slotuse)
                {
                    BTREE_ASSERT(parent->childid[parentslot] == curr);
                    parent->slotkey[parentslot] = leaf->slotkey[leaf->slotuse - 1];
                }
                else
                {
                    if (leaf->slotuse >= 1)
                    {
                        BTREE_PRINT("Scheduling lastkeyupdate: key " << leaf->slotkey[leaf->slotuse - 1]);
                        myres |= result_t(btree_update_lastkey, leaf->slotkey[leaf->slotuse - 1]);
                    }
                    else
                    {
                        BTREE_ASSERT(leaf == m_root);
                    }
                }
            }

            if (leaf->isunderflow() && !(leaf == m_root && leaf->slotuse >= 1))
            {
                // determine what to do about the underflow

                // case : if this empty leaf is the root, then delete all nodes
                // and set root to NULL.
                if (leftleaf == NULL && rightleaf == NULL)
                {
                    BTREE_ASSERT(leaf == m_root);
                    BTREE_ASSERT(leaf->slotuse == 0);

                    free_node(m_root);

                    m_root = leaf = NULL;
                    m_headleaf = m_tailleaf = NULL;

                    // will be decremented soon by insert_start()
                    BTREE_ASSERT(m_stats.itemcount == 1);
                    BTREE_ASSERT(m_stats.leaves == 0);
                    BTREE_ASSERT(m_stats.innernodes == 0);

                    return result_t(btree_ok);
                }
                // case : if both left and right leaves would underflow in case of
                // a shift, then merging is necessary. choose the more local merger
                // with our parent
                else if ((leftleaf == NULL || leftleaf->isfew()) && (rightleaf == NULL || rightleaf->isfew()))
                {
                    if (leftparent == parent)
                        myres |= merge_leaves(leftleaf, leaf, leftparent);
                    else
                        myres |= merge_leaves(leaf, rightleaf, rightparent);
                }
                // case : the right leaf has extra data, so balance right with current
                else if ((leftleaf != NULL && leftleaf->isfew()) && (rightleaf != NULL && !rightleaf->isfew()))
                {
                    if (rightparent == parent)
                        myres |= shift_left_leaf(leaf, rightleaf, rightparent, parentslot);
                    else
                        myres |= merge_leaves(leftleaf, leaf, leftparent);
                }
                // case : the left leaf has extra data, so balance left with current
                else if ((leftleaf != NULL && !leftleaf->isfew()) && (rightleaf != NULL && rightleaf->isfew()))
                {
                    if (leftparent == parent)
                        shift_right_leaf(leftleaf, leaf, leftparent, parentslot - 1);
                    else
                        myres |= merge_leaves(leaf, rightleaf, rightparent);
                }
                // case : both the leaf and right leaves have extra data and our
                // parent, choose the leaf with more data
                else if (leftparent == rightparent)
                {
                    if (leftleaf->slotuse <= rightleaf->slotuse)
                        myres |= shift_left_leaf(leaf, rightleaf, rightparent, parentslot);
                    else
                        shift_right_leaf(leftleaf, leaf, leftparent, parentslot - 1);
                }
                else
                {
                    if (leftparent == parent)
                        shift_right_leaf(leftleaf, leaf, leftparent, parentslot - 1);
                    else
                        myres |= shift_left_leaf(leaf, rightleaf, rightparent, parentslot);
                }
            }

            return result_t(myres);
        }
        else // !curr->isleafnode()
        {
            inner_node* inner = static_cast<inner_node*>(curr);
            inner_node* leftinner = static_cast<inner_node*>(left);
            inner_node* rightinner = static_cast<inner_node*>(right);

            node* myleft, * myright;
            inner_node* myleftparent, * myrightparent;

            int slot = find_lower(inner, key);

            if (slot == 0) {
                myleft = (left == NULL) ? NULL : (static_cast<inner_node*>(left))->childid[left->slotuse - 1];
                myleftparent = leftparent;
            }
            else {
                myleft = inner->childid[slot - 1];
                myleftparent = inner;
            }

            if (slot == inner->slotuse) {
                myright = (right == NULL) ? NULL : (static_cast<inner_node*>(right))->childid[0];
                myrightparent = rightparent;
            }
            else {
                myright = inner->childid[slot + 1];
                myrightparent = inner;
            }

            BTREE_PRINT("erase_one_descend into " << inner->childid[slot]);

            result_t result = erase_one_descend(key,
                                                inner->childid[slot],
                                                myleft, myright,
                                                myleftparent, myrightparent,
                                                inner, slot);

            result_t myres = result_t(btree_ok);

            if (result.has(btree_not_found))
            {
                return result_t(result);
            }

            if (result.has(btree_update_lastkey))
            {
                if (parent && parentslot < parent->slotuse)
                {
                    BTREE_PRINT("Fixing lastkeyupdate: key " << result.lastkey << " into parent " << parent << " at parentslot " << parentslot);

                    BTREE_ASSERT(parent->childid[parentslot] == curr);
                    parent->slotkey[parentslot] = result.lastkey;
                }
                else
                {
                    BTREE_PRINT("Forwarding lastkeyupdate: key " << result.lastkey);
                    myres |= result_t(btree_update_lastkey, result.lastkey);
                }
            }

            if (result.has(btree_fixmerge))
            {
                // either the current node or the next is empty and should be removed
                if (inner->childid[slot]->slotuse != 0)
                    slot++;

                // this is the child slot invalidated by the merge
                BTREE_ASSERT(inner->childid[slot]->slotuse == 0);

                free_node(inner->childid[slot]);

                std::copy(inner->slotkey + slot, inner->slotkey + inner->slotuse,
                          inner->slotkey + slot - 1);
                std::copy(inner->childid + slot + 1, inner->childid + inner->slotuse + 1,
                          inner->childid + slot);

                inner->slotuse--;

                if (inner->level == 1)
                {
                    // fix split key for children leaves
                    slot--;
                    leaf_node* child = static_cast<leaf_node*>(inner->childid[slot]);
                    inner->slotkey[slot] = child->slotkey[child->slotuse - 1];
                }
            }

            if (inner->isunderflow() && !(inner == m_root && inner->slotuse >= 1))
            {
                // case: the inner node is the root and has just one child. that child becomes the new root
                if (leftinner == NULL && rightinner == NULL)
                {
                    BTREE_ASSERT(inner == m_root);
                    BTREE_ASSERT(inner->slotuse == 0);

                    m_root = inner->childid[0];

                    inner->slotuse = 0;
                    free_node(inner);

                    return result_t(btree_ok);
                }
                // case : if both left and right leaves would underflow in case of
                // a shift, then merging is necessary. choose the more local merger
                // with our parent
                else if ((leftinner == NULL || leftinner->isfew()) && (rightinner == NULL || rightinner->isfew()))
                {
                    if (leftparent == parent)
                        myres |= merge_inner(leftinner, inner, leftparent, parentslot - 1);
                    else
                        myres |= merge_inner(inner, rightinner, rightparent, parentslot);
                }
                // case : the right leaf has extra data, so balance right with current
                else if ((leftinner != NULL && leftinner->isfew()) && (rightinner != NULL && !rightinner->isfew()))
                {
                    if (rightparent == parent)
                        shift_left_inner(inner, rightinner, rightparent, parentslot);
                    else
                        myres |= merge_inner(leftinner, inner, leftparent, parentslot - 1);
                }
                // case : the left leaf has extra data, so balance left with current
                else if ((leftinner != NULL && !leftinner->isfew()) && (rightinner != NULL && rightinner->isfew()))
                {
                    if (leftparent == parent)
                        shift_right_inner(leftinner, inner, leftparent, parentslot - 1);
                    else
                        myres |= merge_inner(inner, rightinner, rightparent, parentslot);
                }
                // case : both the leaf and right leaves have extra data and our
                // parent, choose the leaf with more data
                else if (leftparent == rightparent)
                {
                    if (leftinner->slotuse <= rightinner->slotuse)
                        shift_left_inner(inner, rightinner, rightparent, parentslot);
                    else
                        shift_right_inner(leftinner, inner, leftparent, parentslot - 1);
                }
                else
                {
                    if (leftparent == parent)
                        shift_right_inner(leftinner, inner, leftparent, parentslot - 1);
                    else
                        shift_left_inner(inner, rightinner, rightparent, parentslot);
                }
            }

            return result_t(myres);
        }
    }

    /** @brief Erase one key/data pair referenced by an iterator in the B+
     * tree.
     *
     * Descends down the tree in search of an iterator. During the descent the
     * parent, left and right siblings and their parents are computed and
     * passed down. The difficulty is that the iterator contains only a pointer
     * to a leaf_node, which means that this function must do a recursive depth
     * first search for that leaf node in the subtree containing all pairs of
     * the same key. This subtree can be very large, even the whole tree,
     * though in practice it would not make sense to have so many duplicate
     * keys.
     *
     * Once the referenced key/data pair is found, it is removed from the leaf
     * and the same underflow cases are handled as in erase_one_descend.
     */
    result_t erase_iter_descend(const iterator& iter,
                                node* curr,
                                node* left, node* right,
                                inner_node* leftparent, inner_node* rightparent,
                                inner_node* parent, unsigned int parentslot)
    {
        if (curr->isleafnode())
        {
            leaf_node* leaf = static_cast<leaf_node*>(curr);
            leaf_node* leftleaf = static_cast<leaf_node*>(left);
            leaf_node* rightleaf = static_cast<leaf_node*>(right);

            // if this is not the correct leaf, get next step in recursive
            // search
            if (leaf != iter.currnode)
            {
                return result_t(btree_not_found);
            }

            if (iter.currslot >= leaf->slotuse)
            {
                BTREE_PRINT("Could not find iterator (" << iter.currnode << "," << iter.currslot << ") to erase. Invalid leaf node?");

                return result_t(btree_not_found);
            }

            int slot = iter.currslot;

            BTREE_PRINT("Found iterator in leaf " << curr << " at slot " << slot);

            std::copy(leaf->slotkey + slot + 1, leaf->slotkey + leaf->slotuse,
                      leaf->slotkey + slot);
            data_copy(leaf->slotdata + slot + 1, leaf->slotdata + leaf->slotuse,
                      leaf->slotdata + slot);

            leaf->slotuse--;

            result_t myres = result_t(btree_ok);

            // if the last key of the leaf was changed, the parent is notified
            // and updates the key of this leaf
            if (slot == leaf->slotuse)
            {
                if (parent && parentslot < parent->slotuse)
                {
                    BTREE_ASSERT(parent->childid[parentslot] == curr);
                    parent->slotkey[parentslot] = leaf->slotkey[leaf->slotuse - 1];
                }
                else
                {
                    if (leaf->slotuse >= 1)
                    {
                        BTREE_PRINT("Scheduling lastkeyupdate: key " << leaf->slotkey[leaf->slotuse - 1]);
                        myres |= result_t(btree_update_lastkey, leaf->slotkey[leaf->slotuse - 1]);
                    }
                    else
                    {
                        BTREE_ASSERT(leaf == m_root);
                    }
                }
            }

            if (leaf->isunderflow() && !(leaf == m_root && leaf->slotuse >= 1))
            {
                // determine what to do about the underflow

                // case : if this empty leaf is the root, then delete all nodes
                // and set root to NULL.
                if (leftleaf == NULL && rightleaf == NULL)
                {
                    BTREE_ASSERT(leaf == m_root);
                    BTREE_ASSERT(leaf->slotuse == 0);

                    free_node(m_root);

                    m_root = leaf = NULL;
                    m_headleaf = m_tailleaf = NULL;

                    // will be decremented soon by insert_start()
                    BTREE_ASSERT(m_stats.itemcount == 1);
                    BTREE_ASSERT(m_stats.leaves == 0);
                    BTREE_ASSERT(m_stats.innernodes == 0);

                    return result_t(btree_ok);
                }
                // case : if both left and right leaves would underflow in case of
                // a shift, then merging is necessary. choose the more local merger
                // with our parent
                else if ((leftleaf == NULL || leftleaf->isfew()) && (rightleaf == NULL || rightleaf->isfew()))
                {
                    if (leftparent == parent)
                        myres |= merge_leaves(leftleaf, leaf, leftparent);
                    else
                        myres |= merge_leaves(leaf, rightleaf, rightparent);
                }
                // case : the right leaf has extra data, so balance right with current
                else if ((leftleaf != NULL && leftleaf->isfew()) && (rightleaf != NULL && !rightleaf->isfew()))
                {
                    if (rightparent == parent)
                        myres |= shift_left_leaf(leaf, rightleaf, rightparent, parentslot);
                    else
                        myres |= merge_leaves(leftleaf, leaf, leftparent);
                }
                // case : the left leaf has extra data, so balance left with current
                else if ((leftleaf != NULL && !leftleaf->isfew()) && (rightleaf != NULL && rightleaf->isfew()))
                {
                    if (leftparent == parent)
                        shift_right_leaf(leftleaf, leaf, leftparent, parentslot - 1);
                    else
                        myres |= merge_leaves(leaf, rightleaf, rightparent);
                }
                // case : both the leaf and right leaves have extra data and our
                // parent, choose the leaf with more data
                else if (leftparent == rightparent)
                {
                    if (leftleaf->slotuse <= rightleaf->slotuse)
                        myres |= shift_left_leaf(leaf, rightleaf, rightparent, parentslot);
                    else
                        shift_right_leaf(leftleaf, leaf, leftparent, parentslot - 1);
                }
                else
                {
                    if (leftparent == parent)
                        shift_right_leaf(leftleaf, leaf, leftparent, parentslot - 1);
                    else
                        myres |= shift_left_leaf(leaf, rightleaf, rightparent, parentslot);
                }
            }

            return myres;
        }
        else // !curr->isleafnode()
        {
            inner_node* inner = static_cast<inner_node*>(curr);
            inner_node* leftinner = static_cast<inner_node*>(left);
            inner_node* rightinner = static_cast<inner_node*>(right);

            // find first slot below which the searched iterator might be
            // located.

            result_t result;
            int slot = find_lower(inner, iter.key());

            while (slot <= inner->slotuse)
            {
                node* myleft, * myright;
                inner_node* myleftparent, * myrightparent;

                if (slot == 0) {
                    myleft = (left == NULL) ? NULL : (static_cast<inner_node*>(left))->childid[left->slotuse - 1];
                    myleftparent = leftparent;
                }
                else {
                    myleft = inner->childid[slot - 1];
                    myleftparent = inner;
                }

                if (slot == inner->slotuse) {
                    myright = (right == NULL) ? NULL : (static_cast<inner_node*>(right))->childid[0];
                    myrightparent = rightparent;
                }
                else {
                    myright = inner->childid[slot + 1];
                    myrightparent = inner;
                }

                BTREE_PRINT("erase_iter_descend into " << inner->childid[slot]);

                result = erase_iter_descend(iter,
                                            inner->childid[slot],
                                            myleft, myright,
                                            myleftparent, myrightparent,
                                            inner, slot);

                if (!result.has(btree_not_found))
                    break;

                // continue recursive search for leaf on next slot

                if (slot < inner->slotuse && key_less(inner->slotkey[slot], iter.key()))
                    return result_t(btree_not_found);

                ++slot;
            }

            if (slot > inner->slotuse)
                return result_t(btree_not_found);

            result_t myres = result_t(btree_ok);

            if (result.has(btree_update_lastkey))
            {
                if (parent && parentslot < parent->slotuse)
                {
                    BTREE_PRINT("Fixing lastkeyupdate: key " << result.lastkey << " into parent " << parent << " at parentslot " << parentslot);

                    BTREE_ASSERT(parent->childid[parentslot] == curr);
                    parent->slotkey[parentslot] = result.lastkey;
                }
                else
                {
                    BTREE_PRINT("Forwarding lastkeyupdate: key " << result.lastkey);
                    myres |= result_t(btree_update_lastkey, result.lastkey);
                }
            }

            if (result.has(btree_fixmerge))
            {
                // either the current node or the next is empty and should be removed
                if (inner->childid[slot]->slotuse != 0)
                    slot++;

                // this is the child slot invalidated by the merge
                BTREE_ASSERT(inner->childid[slot]->slotuse == 0);

                free_node(inner->childid[slot]);

                std::copy(inner->slotkey + slot, inner->slotkey + inner->slotuse,
                          inner->slotkey + slot - 1);
                std::copy(inner->childid + slot + 1, inner->childid + inner->slotuse + 1,
                          inner->childid + slot);

                inner->slotuse--;

                if (inner->level == 1)
                {
                    // fix split key for children leaves
                    slot--;
                    leaf_node* child = static_cast<leaf_node*>(inner->childid[slot]);
                    inner->slotkey[slot] = child->slotkey[child->slotuse - 1];
                }
            }

            if (inner->isunderflow() && !(inner == m_root && inner->slotuse >= 1))
            {
                // case: the inner node is the root and has just one
                // child. that child becomes the new root
                if (leftinner == NULL && rightinner == NULL)
                {
                    BTREE_ASSERT(inner == m_root);
                    BTREE_ASSERT(inner->slotuse == 0);

                    m_root = inner->childid[0];

                    inner->slotuse = 0;
                    free_node(inner);

                    return result_t(btree_ok);
                }
                // case : if both left and right leaves would underflow in case of
                // a shift, then merging is necessary. choose the more local merger
                // with our parent
                else if ((leftinner == NULL || leftinner->isfew()) && (rightinner == NULL || rightinner->isfew()))
                {
                    if (leftparent == parent)
                        myres |= merge_inner(leftinner, inner, leftparent, parentslot - 1);
                    else
                        myres |= merge_inner(inner, rightinner, rightparent, parentslot);
                }
                // case : the right leaf has extra data, so balance right with current
                else if ((leftinner != NULL && leftinner->isfew()) && (rightinner != NULL && !rightinner->isfew()))
                {
                    if (rightparent == parent)
                        shift_left_inner(inner, rightinner, rightparent, parentslot);
                    else
                        myres |= merge_inner(leftinner, inner, leftparent, parentslot - 1);
                }
                // case : the left leaf has extra data, so balance left with current
                else if ((leftinner != NULL && !leftinner->isfew()) && (rightinner != NULL && rightinner->isfew()))
                {
                    if (leftparent == parent)
                        shift_right_inner(leftinner, inner, leftparent, parentslot - 1);
                    else
                        myres |= merge_inner(inner, rightinner, rightparent, parentslot);
                }
                // case : both the leaf and right leaves have extra data and our
                // parent, choose the leaf with more data
                else if (leftparent == rightparent)
                {
                    if (leftinner->slotuse <= rightinner->slotuse)
                        shift_left_inner(inner, rightinner, rightparent, parentslot);
                    else
                        shift_right_inner(leftinner, inner, leftparent, parentslot - 1);
                }
                else
                {
                    if (leftparent == parent)
                        shift_right_inner(leftinner, inner, leftparent, parentslot - 1);
                    else
                        shift_left_inner(inner, rightinner, rightparent, parentslot);
                }
            }

            return result_t(myres);
        }
    }

    /// Merge two leaf nodes. The function moves all key/data pairs from right
    /// to left and sets right's slotuse to zero. The right slot is then
    /// removed by the calling parent node.
    result_t merge_leaves(leaf_node* left, leaf_node* right, inner_node* parent)
    {
        BTREE_PRINT("Merge leaf nodes " << left << " and " << right << " with common parent " << parent << ".");
        (void)parent;

        BTREE_ASSERT(left->isleafnode() && right->isleafnode());
        BTREE_ASSERT(parent->level == 1);

        BTREE_ASSERT(left->slotuse + right->slotuse < leafslotmax);

        std::copy(right->slotkey, right->slotkey + right->slotuse,
                  left->slotkey + left->slotuse);
        data_copy(right->slotdata, right->slotdata + right->slotuse,
                  left->slotdata + left->slotuse);

        left->slotuse += right->slotuse;

        left->nextleaf = right->nextleaf;
        if (left->nextleaf)
            left->nextleaf->prevleaf = left;
        else
            m_tailleaf = left;

        right->slotuse = 0;

        return result_t(btree_fixmerge);
    }

    /// Merge two inner nodes. The function moves all key/childid pairs from
    /// right to left and sets right's slotuse to zero. The right slot is then
    /// removed by the calling parent node.
    static result_t merge_inner(inner_node* left, inner_node* right, inner_node* parent, unsigned int parentslot)
    {
        BTREE_PRINT("Merge inner nodes " << left << " and " << right << " with common parent " << parent << ".");

        BTREE_ASSERT(left->level == right->level);
        BTREE_ASSERT(parent->level == left->level + 1);

        BTREE_ASSERT(parent->childid[parentslot] == left);

        BTREE_ASSERT(left->slotuse + right->slotuse < innerslotmax);

        if (selfverify)
        {
            // find the left node's slot in the parent's children
            unsigned int leftslot = 0;
            while (leftslot <= parent->slotuse && parent->childid[leftslot] != left)
                ++leftslot;

            BTREE_ASSERT(leftslot < parent->slotuse);
            BTREE_ASSERT(parent->childid[leftslot] == left);
            BTREE_ASSERT(parent->childid[leftslot + 1] == right);

            BTREE_ASSERT(parentslot == leftslot);
        }

        // retrieve the decision key from parent
        left->slotkey[left->slotuse] = parent->slotkey[parentslot];
        left->slotuse++;

        // copy over keys and children from right
        std::copy(right->slotkey, right->slotkey + right->slotuse,
                  left->slotkey + left->slotuse);
        std::copy(right->childid, right->childid + right->slotuse + 1,
                  left->childid + left->slotuse);

        left->slotuse += right->slotuse;
        right->slotuse = 0;

        return result_t(btree_fixmerge);
    }

    /// Balance two leaf nodes. The function moves key/data pairs from right to
    /// left so that both nodes are equally filled. The parent node is updated
    /// if possible.
    static result_t shift_left_leaf(leaf_node* left, leaf_node* right, inner_node* parent, unsigned int parentslot)
    {
        BTREE_ASSERT(left->isleafnode() && right->isleafnode());
        BTREE_ASSERT(parent->level == 1);

        BTREE_ASSERT(left->nextleaf == right);
        BTREE_ASSERT(left == right->prevleaf);

        BTREE_ASSERT(left->slotuse < right->slotuse);
        BTREE_ASSERT(parent->childid[parentslot] == left);

        unsigned int shiftnum = (right->slotuse - left->slotuse) >> 1;

        BTREE_PRINT("Shifting (leaf) " << shiftnum << " entries to left " << left << " from right " << right << " with common parent " << parent << ".");

        BTREE_ASSERT(left->slotuse + shiftnum < leafslotmax);

        // copy the first items from the right node to the last slot in the left node.

        std::copy(right->slotkey, right->slotkey + shiftnum,
                  left->slotkey + left->slotuse);
        data_copy(right->slotdata, right->slotdata + shiftnum,
                  left->slotdata + left->slotuse);

        left->slotuse += shiftnum;

        // shift all slots in the right node to the left

        std::copy(right->slotkey + shiftnum, right->slotkey + right->slotuse,
                  right->slotkey);
        data_copy(right->slotdata + shiftnum, right->slotdata + right->slotuse,
                  right->slotdata);

        right->slotuse -= shiftnum;

        // fixup parent
        if (parentslot < parent->slotuse) {
            parent->slotkey[parentslot] = left->slotkey[left->slotuse - 1];
            return result_t(btree_ok);
        }
        else {  // the update is further up the tree
            return result_t(btree_update_lastkey, left->slotkey[left->slotuse - 1]);
        }
    }

    /// Balance two inner nodes. The function moves key/data pairs from right
    /// to left so that both nodes are equally filled. The parent node is
    /// updated if possible.
    static void shift_left_inner(inner_node* left, inner_node* right, inner_node* parent, unsigned int parentslot)
    {
        BTREE_ASSERT(left->level == right->level);
        BTREE_ASSERT(parent->level == left->level + 1);

        BTREE_ASSERT(left->slotuse < right->slotuse);
        BTREE_ASSERT(parent->childid[parentslot] == left);

        unsigned int shiftnum = (right->slotuse - left->slotuse) >> 1;

        BTREE_PRINT("Shifting (inner) " << shiftnum << " entries to left " << left << " from right " << right << " with common parent " << parent << ".");

        BTREE_ASSERT(left->slotuse + shiftnum < innerslotmax);

        if (selfverify)
        {
            // find the left node's slot in the parent's children and compare to parentslot

            unsigned int leftslot = 0;
            while (leftslot <= parent->slotuse && parent->childid[leftslot] != left)
                ++leftslot;

            BTREE_ASSERT(leftslot < parent->slotuse);
            BTREE_ASSERT(parent->childid[leftslot] == left);
            BTREE_ASSERT(parent->childid[leftslot + 1] == right);

            BTREE_ASSERT(leftslot == parentslot);
        }

        // copy the parent's decision slotkey and childid to the first new key on the left
        left->slotkey[left->slotuse] = parent->slotkey[parentslot];
        left->slotuse++;

        // copy the other items from the right node to the last slots in the left node.

        std::copy(right->slotkey, right->slotkey + shiftnum - 1,
                  left->slotkey + left->slotuse);
        std::copy(right->childid, right->childid + shiftnum,
                  left->childid + left->slotuse);

        left->slotuse += shiftnum - 1;

        // fixup parent
        parent->slotkey[parentslot] = right->slotkey[shiftnum - 1];

        // shift all slots in the right node

        std::copy(right->slotkey + shiftnum, right->slotkey + right->slotuse,
                  right->slotkey);
        std::copy(right->childid + shiftnum, right->childid + right->slotuse + 1,
                  right->childid);

        right->slotuse -= shiftnum;
    }

    /// Balance two leaf nodes. The function moves key/data pairs from left to
    /// right so that both nodes are equally filled. The parent node is updated
    /// if possible.
    static void shift_right_leaf(leaf_node* left, leaf_node* right, inner_node* parent, unsigned int parentslot)
    {
        BTREE_ASSERT(left->isleafnode() && right->isleafnode());
        BTREE_ASSERT(parent->level == 1);

        BTREE_ASSERT(left->nextleaf == right);
        BTREE_ASSERT(left == right->prevleaf);
        BTREE_ASSERT(parent->childid[parentslot] == left);

        BTREE_ASSERT(left->slotuse > right->slotuse);

        unsigned int shiftnum = (left->slotuse - right->slotuse) >> 1;

        BTREE_PRINT("Shifting (leaf) " << shiftnum << " entries to right " << right << " from left " << left << " with common parent " << parent << ".");

        if (selfverify)
        {
            // find the left node's slot in the parent's children
            unsigned int leftslot = 0;
            while (leftslot <= parent->slotuse && parent->childid[leftslot] != left)
                ++leftslot;

            BTREE_ASSERT(leftslot < parent->slotuse);
            BTREE_ASSERT(parent->childid[leftslot] == left);
            BTREE_ASSERT(parent->childid[leftslot + 1] == right);

            BTREE_ASSERT(leftslot == parentslot);
        }

        // shift all slots in the right node

        BTREE_ASSERT(right->slotuse + shiftnum < leafslotmax);

        std::copy_backward(right->slotkey, right->slotkey + right->slotuse,
                           right->slotkey + right->slotuse + shiftnum);
        data_copy_backward(right->slotdata, right->slotdata + right->slotuse,
                           right->slotdata + right->slotuse + shiftnum);

        right->slotuse += shiftnum;

        // copy the last items from the left node to the first slot in the right node.
        std::copy(left->slotkey + left->slotuse - shiftnum, left->slotkey + left->slotuse,
                  right->slotkey);
        data_copy(left->slotdata + left->slotuse - shiftnum, left->slotdata + left->slotuse,
                  right->slotdata);

        left->slotuse -= shiftnum;

        parent->slotkey[parentslot] = left->slotkey[left->slotuse - 1];
    }

    /// Balance two inner nodes. The function moves key/data pairs from left to
    /// right so that both nodes are equally filled. The parent node is updated
    /// if possible.
    static void shift_right_inner(inner_node* left, inner_node* right, inner_node* parent, unsigned int parentslot)
    {
        BTREE_ASSERT(left->level == right->level);
        BTREE_ASSERT(parent->level == left->level + 1);

        BTREE_ASSERT(left->slotuse > right->slotuse);
        BTREE_ASSERT(parent->childid[parentslot] == left);

        unsigned int shiftnum = (left->slotuse - right->slotuse) >> 1;

        BTREE_PRINT("Shifting (leaf) " << shiftnum << " entries to right " << right << " from left " << left << " with common parent " << parent << ".");

        if (selfverify)
        {
            // find the left node's slot in the parent's children
            unsigned int leftslot = 0;
            while (leftslot <= parent->slotuse && parent->childid[leftslot] != left)
                ++leftslot;

            BTREE_ASSERT(leftslot < parent->slotuse);
            BTREE_ASSERT(parent->childid[leftslot] == left);
            BTREE_ASSERT(parent->childid[leftslot + 1] == right);

            BTREE_ASSERT(leftslot == parentslot);
        }

        // shift all slots in the right node

        BTREE_ASSERT(right->slotuse + shiftnum < innerslotmax);

        std::copy_backward(right->slotkey, right->slotkey + right->slotuse,
                           right->slotkey + right->slotuse + shiftnum);
        std::copy_backward(right->childid, right->childid + right->slotuse + 1,
                           right->childid + right->slotuse + 1 + shiftnum);

        right->slotuse += shiftnum;

        // copy the parent's decision slotkey and childid to the last new key on the right
        right->slotkey[shiftnum - 1] = parent->slotkey[parentslot];

        // copy the remaining last items from the left node to the first slot in the right node.
        std::copy(left->slotkey + left->slotuse - shiftnum + 1, left->slotkey + left->slotuse,
                  right->slotkey);
        std::copy(left->childid + left->slotuse - shiftnum + 1, left->childid + left->slotuse + 1,
                  right->childid);

        // copy the first to-be-removed key from the left node to the parent's decision slot
        parent->slotkey[parentslot] = left->slotkey[left->slotuse - shiftnum];

        left->slotuse -= shiftnum;
    }

#ifdef BTREE_DEBUG

public:
    // *** Debug Printing

    /// Print out the B+ tree structure with keys onto the given ostream. This
    /// function requires that the header is compiled with BTREE_DEBUG and that
    /// key_type is printable via std::ostream.
    void print(std::ostream& os) const
    {
        if (m_root) {
            print_node(os, m_root, 0, true);
        }
    }

    /// Print out only the leaves via the double linked list.
    void print_leaves(std::ostream& os) const
    {
        os << "leaves:" << std::endl;

        const leaf_node* n = m_headleaf;

        while (n)
        {
            os << "  " << n << std::endl;

            n = n->nextleaf;
        }
    }

private:
    /// Recursively descend down the tree and print out nodes.
    static void print_node(std::ostream& os, const node* node, unsigned int depth = 0, bool recursive = false)
    {
        for (unsigned int i = 0; i < depth; i++) os << "  ";

        os << "node " << node << " level " << node->level << " slotuse " << node->slotuse << std::endl;

        if (node->isleafnode())
        {
            const leaf_node* leafnode = static_cast<const leaf_node*>(node);

            for (unsigned int i = 0; i < depth; i++) os << "  ";
            os << "  leaf prev " << leafnode->prevleaf << " next " << leafnode->nextleaf << std::endl;

            for (unsigned int i = 0; i < depth; i++) os << "  ";

            for (unsigned int slot = 0; slot < leafnode->slotuse; ++slot)
            {
                os << leafnode->slotkey[slot] << "  "; // << "(data: " << leafnode->slotdata[slot] << ") ";
            }
            os << std::endl;
        }
        else
        {
            const inner_node* innernode = static_cast<const inner_node*>(node);

            for (unsigned int i = 0; i < depth; i++) os << "  ";

            for (unsigned short slot = 0; slot < innernode->slotuse; ++slot)
            {
                os << "(" << innernode->childid[slot] << ") " << innernode->slotkey[slot] << " ";
            }
            os << "(" << innernode->childid[innernode->slotuse] << ")" << std::endl;

            if (recursive)
            {
                for (unsigned short slot = 0; slot < innernode->slotuse + 1; ++slot)
                {
                    print_node(os, innernode->childid[slot], depth + 1, recursive);
                }
            }
        }
    }
#endif

public:
    // *** Verification of B+ Tree Invariants

    /// Run a thorough verification of all B+ tree invariants. The program
    /// aborts via assert() if something is wrong.
    void verify() const
    {
        key_type minkey, maxkey;
        tree_stats vstats;

        if (m_root)
        {
            verify_node(m_root, &minkey, &maxkey, vstats);

            assert(vstats.itemcount == m_stats.itemcount);
            assert(vstats.leaves == m_stats.leaves);
            assert(vstats.innernodes == m_stats.innernodes);

            verify_leaflinks();
        }
    }

private:
    /// Recursively descend down the tree and verify each node
    void verify_node(const node* n, key_type* minkey, key_type* maxkey, tree_stats& vstats) const
    {
        BTREE_PRINT("verifynode " << n);

        if (n->isleafnode())
        {
            const leaf_node* leaf = static_cast<const leaf_node*>(n);

            assert(leaf == m_root || !leaf->isunderflow());
            assert(leaf->slotuse > 0);

            for (unsigned short slot = 0; slot < leaf->slotuse - 1; ++slot)
            {
                assert(key_lessequal(leaf->slotkey[slot], leaf->slotkey[slot + 1]));
            }

            *minkey = leaf->slotkey[0];
            *maxkey = leaf->slotkey[leaf->slotuse - 1];

            vstats.leaves++;
            vstats.itemcount += leaf->slotuse;
        }
        else // !n->isleafnode()
        {
            const inner_node* inner = static_cast<const inner_node*>(n);
            vstats.innernodes++;

            assert(inner == m_root || !inner->isunderflow());
            assert(inner->slotuse > 0);

            for (unsigned short slot = 0; slot < inner->slotuse - 1; ++slot)
            {
                assert(key_lessequal(inner->slotkey[slot], inner->slotkey[slot + 1]));
            }

            for (unsigned short slot = 0; slot <= inner->slotuse; ++slot)
            {
                const node* subnode = inner->childid[slot];
                key_type subminkey = key_type();
                key_type submaxkey = key_type();

                assert(subnode->level + 1 == inner->level);
                verify_node(subnode, &subminkey, &submaxkey, vstats);

                BTREE_PRINT("verify subnode " << subnode << ": " << subminkey << " - " << submaxkey);

                if (slot == 0)
                    *minkey = subminkey;
                else
                    assert(key_greaterequal(subminkey, inner->slotkey[slot - 1]));

                if (slot == inner->slotuse)
                    *maxkey = submaxkey;
                else
                    assert(key_equal(inner->slotkey[slot], submaxkey));

                if (inner->level == 1 && slot < inner->slotuse)
                {
                    // children are leaves and must be linked together in the
                    // correct order
                    const leaf_node* leafa = static_cast<const leaf_node*>(inner->childid[slot]);
                    const leaf_node* leafb = static_cast<const leaf_node*>(inner->childid[slot + 1]);

                    assert(leafa->nextleaf == leafb);
                    assert(leafa == leafb->prevleaf);
                    (void)leafa;
                    (void)leafb;
                }
                if (inner->level == 2 && slot < inner->slotuse)
                {
                    // verify leaf links between the adjacent inner nodes
                    const inner_node* parenta = static_cast<const inner_node*>(inner->childid[slot]);
                    const inner_node* parentb = static_cast<const inner_node*>(inner->childid[slot + 1]);

                    const leaf_node* leafa = static_cast<const leaf_node*>(parenta->childid[parenta->slotuse]);
                    const leaf_node* leafb = static_cast<const leaf_node*>(parentb->childid[0]);

                    assert(leafa->nextleaf == leafb);
                    assert(leafa == leafb->prevleaf);
                    (void)leafa;
                    (void)leafb;
                }
            }
        }
    }

    /// Verify the double linked list of leaves.
    void verify_leaflinks() const
    {
        const leaf_node* n = m_headleaf;

        assert(n->level == 0);
        assert(!n || n->prevleaf == NULL);

        unsigned int testcount = 0;

        while (n)
        {
            assert(n->level == 0);
            assert(n->slotuse > 0);

            for (unsigned short slot = 0; slot < n->slotuse - 1; ++slot)
            {
                assert(key_lessequal(n->slotkey[slot], n->slotkey[slot + 1]));
            }

            testcount += n->slotuse;

            if (n->nextleaf)
            {
                assert(key_lessequal(n->slotkey[n->slotuse - 1], n->nextleaf->slotkey[0]));

                assert(n == n->nextleaf->prevleaf);
            }
            else
            {
                assert(m_tailleaf == n);
            }

            n = n->nextleaf;
        }

        assert(testcount == size());
    }

private:
    // *** Dump and Restore of B+ Trees

    /// A header for the binary image containing the base properties of the B+
    /// tree. These properties have to match the current template
    /// instantiation.
    struct dump_header
    {
        /// "stx-btree", just to stop the restore() function from loading garbage
        char           signature[12];

        /// Currently 0
        unsigned short version;

        /// sizeof(key_type)
        unsigned short key_type_size;

        /// sizeof(data_type)
        unsigned short data_type_size;

        /// Number of slots in the leaves
        unsigned short leafslots;

        /// Number of slots in the inner nodes
        unsigned short innerslots;

        /// Allow duplicates
        bool           allow_duplicates;

        /// The item count of the tree
        size_type      itemcount;

        /// Fill the struct with the current B+ tree's properties, itemcount is
        /// not filled.
        inline void    fill()
        {
            // don't want to include string.h just for this signature
            signature[0] = 's';
            signature[1] = 't';
            signature[2] = 'x';
            signature[3] = '-';
            signature[4] = 'b';
            signature[5] = 't';
            signature[6] = 'r';
            signature[7] = 'e';
            signature[8] = 'e';
            signature[9] = 0;
            signature[10] = 0;
            signature[11] = 0;

            version = 0;
            key_type_size = sizeof(typename self_type::key_type);
            data_type_size = sizeof(typename self_type::data_type);
            leafslots = self_type::leafslotmax;
            innerslots = self_type::innerslotmax;
            allow_duplicates = self_type::allow_duplicates;
        }

        /// Returns true if the headers have the same vital properties
        inline bool same(const struct dump_header& o) const
        {
            return (signature[0] == 's' && signature[1] == 't' &&
                    signature[2] == 'x' && signature[3] == '-' &&
                    signature[4] == 'b' && signature[5] == 't' &&
                    signature[6] == 'r' && signature[7] == 'e' &&
                    signature[8] == 'e' && signature[9] == 0 &&
                    signature[10] == 0 && signature[11] == 0)
                   && (version == o.version)
                   && (key_type_size == o.key_type_size)
                   && (data_type_size == o.data_type_size)
                   && (leafslots == o.leafslots)
                   && (innerslots == o.innerslots)
                   && (allow_duplicates == o.allow_duplicates);
        }
    };

public:
    /// Dump the contents of the B+ tree out onto an ostream as a binary
    /// image. The image contains memory pointers which will be fixed when the
    /// image is restored. For this to work your key_type and data_type must be
    /// integral types and contain no pointers or references.
    void dump(std::ostream& os) const
    {
        struct dump_header header;
        header.fill();
        header.itemcount = size();

        os.write(reinterpret_cast<char*>(&header), sizeof(header));

        if (m_root) {
            dump_node(os, m_root);
        }
    }

    /// Restore a binary image of a dumped B+ tree from an istream. The B+ tree
    /// pointers are fixed using the dump order. For dump and restore to work
    /// your key_type and data_type must be integral types and contain no
    /// pointers or references. Returns true if the restore was successful.
    bool restore(std::istream& is)
    {
        struct dump_header fileheader;
        is.read(reinterpret_cast<char*>(&fileheader), sizeof(fileheader));
        if (!is.good()) return false;

        struct dump_header myheader;
        myheader.fill();
        myheader.itemcount = fileheader.itemcount;

        if (!myheader.same(fileheader))
        {
            BTREE_PRINT("btree::restore: file header does not match instantiation signature.");
            return false;
        }

        clear();

        if (fileheader.itemcount > 0)
        {
            m_root = restore_node(is);
            if (m_root == NULL) return false;

            m_stats.itemcount = fileheader.itemcount;
        }

#ifdef BTREE_DEBUG
        if (debug) print(std::cout);
#endif
        if (selfverify) verify();

        return true;
    }

private:
    /// Recursively descend down the tree and dump each node in a precise order
    void dump_node(std::ostream& os, const node* n) const
    {
        BTREE_PRINT("dump_node " << n << std::endl);

        if (n->isleafnode())
        {
            const leaf_node* leaf = static_cast<const leaf_node*>(n);

            os.write(reinterpret_cast<const char*>(leaf), sizeof(*leaf));
        }
        else // !n->isleafnode()
        {
            const inner_node* inner = static_cast<const inner_node*>(n);

            os.write(reinterpret_cast<const char*>(inner), sizeof(*inner));

            for (unsigned short slot = 0; slot <= inner->slotuse; ++slot)
            {
                const node* subnode = inner->childid[slot];

                dump_node(os, subnode);
            }
        }
    }

    /// Read the dump image and construct a tree from the node order in the
    /// serialization.
    node * restore_node(std::istream& is)
    {
        node top(0);

        // first read only the top of the node
        is.read(reinterpret_cast<char*>(&top), sizeof(top));
        if (!is.good()) return NULL;

        if (top.isleafnode())
        {
            leaf_node leaf(top);

            // read remaining data of leaf node
            is.read(reinterpret_cast<char*>(&leaf) + sizeof(top), sizeof(leaf) - sizeof(top));
            if (!is.good()) return NULL;

            leaf_node* newleaf = allocate_leaf();

            // copy over all data, the leaf nodes contain only their double linked list pointers
            *newleaf = leaf;

            // reconstruct the linked list from the order in the file
            if (m_headleaf == NULL) {
                BTREE_ASSERT(newleaf->prevleaf == NULL);
                m_headleaf = m_tailleaf = newleaf;
            }
            else {
                newleaf->prevleaf = m_tailleaf;
                m_tailleaf->nextleaf = newleaf;
                m_tailleaf = newleaf;
            }

            return newleaf;
        }
        else
        {
            inner_node inner(top);

            // read remaining data of inner node
            is.read(reinterpret_cast<char*>(&inner) + sizeof(top), sizeof(inner) - sizeof(top));
            if (!is.good()) return NULL;

            inner_node* newinner = allocate_inner(0);

            // copy over all data, the inner nodes contain only pointers to their children
            *newinner = inner;

            for (unsigned short slot = 0; slot <= newinner->slotuse; ++slot)
            {
                newinner->childid[slot] = restore_node(is);
            }

            return newinner;
        }
    }
};

} // namespace stx

#endif // !STX_STX_BTREE_H_HEADER

/******************************************************************************/
